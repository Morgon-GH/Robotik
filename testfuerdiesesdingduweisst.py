## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)
        elif sensor[2]=='ultrasonic':
            self.s3=UltrasonicSensor_jomo(Port.S3)
        else:
            pass
        if sensor[3]=='gyro':
            self.s4=GyroSensor_jomo(Port.S4)
        elif sensor[3]=='touch':
            self.s4=TouchSensor_jomo(Port.S4)
        elif sensor[3]=='color':
            self.s4=ColorSensor_jomo(Port.S4)
        elif sensor[3]=='infrared':
            self.s4=InfraredSensor_jomo(Port.S4)
        elif sensor[3]=='ultrasonic':
            self.s4=UltrasonicSensor_jomo(Port.S4)
        else:
            pass

    def redo_(self, redo=1):
        if redo==0:
            do.sdo()
        elif redo==1:
            do.redo1()
        elif redo==2:
            do.redo2()
        elif redo==3:
            do.redo3()
        elif redo==4:
            do.redo4()
        elif redo==5:
            do.redo5()
        elif redo==6:
            do.redo6()
        elif redo==7:
            do.redo7()
        elif redo==8:
            do.redo8()
        elif redo==9:
            do.redo9()
        elif redo==10:
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------
##    
#!/usr/bin/env pybricks-micropython



## 1) Commentation Zone-------------------------------------------------------------------------------------------------
##    
##    Author: Johannes und Moritz
##    Language: Micropython (Python) v 2.0
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.
##                        Garbage Collector might needed.
##    File: 
##         Program ( ) 
##         Module  (x)
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)
##    Look for the documentation. If there are questions, write to the Support.



## 2) Import Zone-------------------------------------------------------------------------------------------------------
##    

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile 

import gc



## 3) Moduling Zone--------------------------------------------------------------------------------------------------
##    

class Robotics_jomo(Customclass_jomo):
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.
    Preferences nutzen große Räder, im Abstand von 10cm. 
    '''

    #überschreiben
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):
        #fill
    

    class ColorSensor_jomo(ColorSensor, Customclass_jomo):
        #fill
    

    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):
        #fill
    

    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):
        #fill
    

    class GyroSensor_jomo(GyroSensor, Customclass_jomo):
        #fill    


    class Motor_jomo(Motor, Customclass_jomo):
        #fill

    
    class DriveBase_jomo(DriveBase, Customclass_jomo):
        #fill

        def follow_line(self, line_color=Color.BLACK):
            ##

        ## Fahre bis Ultraschallsensor diesunddas..

        ## Fahre bis Farbsensor diesunddas..

        ## Fahre bis Hell/Dunkelsensor diesunddas..

        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..

        ## Beschleunige diesunddas

        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kurs
    

    #neue, eigene Klassen
    class Extension_jomo(Motor_jomo):
        #fill

    class BgExtension_jomo(Customclass_jomo):
        #fill
    

    class Message_jomo(Customclass_jomo):
        #fill

        ## connect stelle verbindung her

        ## code_messg1 messagecodierer 1

        ## decode_messg1 messagedecodierer 1

        ## code_messg2 messagecodierer 2

        ## decode_messg2 messagedecodierer 2

        ## code_messg3 messagecodierer 3

        ## decode_messg3 messagedecodierer 3
        
        ## code_messg4 messagecodierer 4

        ## decode_messg4 messagedecodierer 4

        ## receive Nachricht empfangen

        ## send Nachricht senden


    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):
        if makeredo==True:
            do=RedoINTE_jomo()
        if driveports[0]!==' ':
            self.a=Motor_jomo(driveports[0])
        if driveports[1]!==' ':
            self.b=Motor_jomo(driveports[1])
        if extports[0]!==' ':
            self.c=Extension_jomo(extports[0])
        if extports[1]!==' ':
            self.d=Extension_jomo(extports[1])
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)

        if sensor[0]=='gyro': 
            self.s1=GyroSensor_jomo(Port.S1)
        elif sensor[0]=='touch':
            self.s1=TouchSensor_jomo(Port.S1)
        elif sensor[0]=='color':
            self.s1=ColorSensor_jomo(Port.S1)
        elif sensor[0]=='infrared':
            self.s1=InfraredSensor_jomo(Port.S1)
        elif sensor[0]=='ultrasonic':
            self.s1=UltrasonicSensor_jomo(Port.S1)
        else:
            pass
        if sensor[1]=='gyro':
            self.s2=GyroSensor_jomo(Port.S2)
        elif sensor[1]=='touch':
            self.s2=TouchSensor_jomo(Port.S2)
        elif sensor[1]=='color':
            self.s2=ColorSensor_jomo(Port.S2)
        elif sensor[1]=='infrared':
            self.s2=InfraredSensor_jomo(Port.S2)
        elif sensor[1]=='ultrasonic':
            self.s2=UltrasonicSensor_jomo(Port.S2)
        else:
            pass
        if sensor[2]=='gyro':
            self.s3=GyroSensor_jomo(Port.S3)
        elif sensor[2]=='touch':
            self.s3=TouchSensor_jomo(Port.S3)
        elif sensor[2]=='color':
            self.s3=ColorSensor_jomo(Port.S3)
        elif sensor[2]=='infrared':
            self.s3=InfraredSensor_jomo(Port.S3)das ist das haus des nikolaus
        elif sensor[2]=='ultrasonic':das ist das haus des nikolaus
            self.s3=UltrasonicSensor_jomo(Port.S3)das ist das haus des nikolaus
        else:das ist das haus des nikolaus
            passdas ist das haus des nikolaus
        if sensor[3]=='gyro':das ist das haus des nikolaus
            self.s4=GyroSensor_jomo(Port.S4)das ist das haus des nikolaus
        elif sensor[3]=='touch':das ist das haus des nikolaus
            self.s4=TouchSensor_jomo(Port.S4)das ist das haus des nikolaus
        elif sensor[3]=='color':das ist das haus des nikolaus
            self.s4=ColorSensor_jomo(Port.S4)das ist das haus des nikolaus
        elif sensor[3]=='infrared':das ist das haus des nikolaus
            self.s4=InfraredSensor_jomo(Port.S4)das ist das haus des nikolaus
        elif sensor[3]=='ultrasonic':das ist das haus des nikolaus
            self.s4=UltrasonicSensor_jomo(Port.S4)das ist das haus des nikolaus
        else:das ist das haus des nikolaus
            passdas ist das haus des nikolaus
das ist das haus des nikolaus
    def redo_(self, redo=1):das ist das haus des nikolaus
        if redo==0:das ist das haus des nikolaus
            do.sdo()das ist das haus des nikolaus
        elif redo==1:das ist das haus des nikolaus
            do.redo1()das ist das haus des nikolaus
        elif redo==2:das ist das haus des nikolaus
            do.redo2()das ist das haus des nikolaus
        elif redo==3:das ist das haus des nikolaus
            do.redo3()das ist das haus des nikolaus
        elif redo==4:das ist das haus des nikolaus
            do.redo4()das ist das haus des nikolaus
        elif redo==5:das ist das haus des nikolaus
            do.redo5()das ist das haus des nikolaus
        elif redo==6:das ist das haus des nikolaus
            do.redo6()das ist das haus des nikolaus
        elif redo==7:das ist das haus des nikolaus
            do.redo7()das ist das haus des nikolaus
        elif redo==8:das ist das haus des nikolaus
            do.redo8()das ist das haus des nikolaus
        elif redo==9:das ist das haus des nikolaus
            do.redo9()das ist das haus des nikolaus
        elif redo==10:das ist das haus des nikolaus
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------das ist das haus des nikolaus
##    das ist das haus des nikolaus
#!/usr/bin/env pybricks-micropythondas ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
## 1) Commentation Zone-------------------------------------------------------------------------------------------------das ist das haus des nikolaus
##    das ist das haus des nikolaus
##    Author: Johannes und Moritzdas ist das haus des nikolaus
##    Language: Micropython (Python) v 2.0das ist das haus des nikolaus
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.das ist das haus des nikolaus
##                        Garbage Collector might needed.das ist das haus des nikolaus
##    File: das ist das haus des nikolaus
##         Program ( ) das ist das haus des nikolaus
##         Module  (x)das ist das haus des nikolaus
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)das ist das haus des nikolaus
##    Look for the documentation. If there are questions, write to the Support.das ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
## 2) Import Zone-------------------------------------------------------------------------------------------------------das ist das haus des nikolaus
##    das ist das haus des nikolaus
das ist das haus des nikolaus
from pybricks.hubs import EV3Brickdas ist das haus des nikolaus
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensordas ist das haus des nikolaus
from pybricks.parameters import Port, Stop, Direction, Button, Colordas ist das haus des nikolaus
from pybricks.tools import wait, StopWatch, DataLogdas ist das haus des nikolaus
from pybricks.robotics import DriveBasedas ist das haus des nikolaus
from pybricks.media.ev3dev import SoundFile, ImageFile das ist das haus des nikolaus
das ist das haus des nikolaus
import gcdas ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
## 3) Moduling Zone--------------------------------------------------------------------------------------------------das ist das haus des nikolaus
##    das ist das haus des nikolaus
das ist das haus des nikolaus
class Robotics_jomo(Customclass_jomo):das ist das haus des nikolaus
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.das ist das haus des nikolaus
    Preferences nutzen große Räder, im Abstand von 10cm. das ist das haus des nikolaus
    '''das ist das haus des nikolaus
das ist das haus des nikolaus
    #überschreibendas ist das haus des nikolaus
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
    das ist das haus des nikolaus
das ist das haus des nikolaus
    class ColorSensor_jomo(ColorSensor, Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
    das ist das haus des nikolaus
das ist das haus des nikolaus
    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
    das ist das haus des nikolaus
das ist das haus des nikolaus
    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
    das ist das haus des nikolaus
das ist das haus des nikolaus
    class GyroSensor_jomo(GyroSensor, Customclass_jomo):das ist das haus des nikolaus
        #fill    das ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
    class Motor_jomo(Motor, Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
das ist das haus des nikolaus
    das ist das haus des nikolaus
    class DriveBase_jomo(DriveBase, Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
das ist das haus des nikolaus
        def follow_line(self, line_color=Color.BLACK):das ist das haus des nikolaus
            ##das ist das haus des nikolaus
das ist das haus des nikolaus
        ## Fahre bis Ultraschallsensor diesunddas..das ist das haus des nikolaus
das ist das haus des nikolaus
        ## Fahre bis Farbsensor diesunddas..das ist das haus des nikolaus
das ist das haus des nikolaus
        ## Fahre bis Hell/Dunkelsensor diesunddas..das ist das haus des nikolaus
das ist das haus des nikolaus
        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..das ist das haus des nikolaus
das ist das haus des nikolaus
        ## Beschleunige diesunddasdas ist das haus des nikolaus
das ist das haus des nikolaus
        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kursdas ist das haus des nikolaus
    das ist das haus des nikolaus
das ist das haus des nikolaus
    #neue, eigene Klassendas ist das haus des nikolaus
    class Extension_jomo(Motor_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
das ist das haus des nikolaus
    class BgExtension_jomo(Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
    das ist das haus des nikolaus
das ist das haus des nikolaus
    class Message_jomo(Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
das ist das haus des nikolaus
        ## connect stelle verbindung herdas ist das haus des nikolaus
das ist das haus des nikolaus
        ## code_messg1 messagecodierer 1das ist das haus des nikolaus
das ist das haus des nikolaus
        ## decode_messg1 messagedecodierer 1das ist das haus des nikolaus
das ist das haus des nikolaus
        ## code_messg2 messagecodierer 2das ist das haus des nikolaus
das ist das haus des nikolaus
        ## decode_messg2 messagedecodierer 2das ist das haus des nikolaus
das ist das haus des nikolaus
        ## code_messg3 messagecodierer 3das ist das haus des nikolaus
das ist das haus des nikolaus
        ## decode_messg3 messagedecodierer 3das ist das haus des nikolaus
        das ist das haus des nikolaus
        ## code_messg4 messagecodierer 4das ist das haus des nikolaus
das ist das haus des nikolaus
        ## decode_messg4 messagedecodierer 4das ist das haus des nikolaus
das ist das haus des nikolaus
        ## receive Nachricht empfangendas ist das haus des nikolaus
das ist das haus des nikolaus
        ## send Nachricht sendendas ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,das ist das haus des nikolaus
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),das ist das haus des nikolaus
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):das ist das haus des nikolaus
        if makeredo==True:das ist das haus des nikolaus
            do=RedoINTE_jomo()das ist das haus des nikolaus
        if driveports[0]!==' ':das ist das haus des nikolaus
            self.a=Motor_jomo(driveports[0])das ist das haus des nikolaus
        if driveports[1]!==' ':das ist das haus des nikolaus
            self.b=Motor_jomo(driveports[1])das ist das haus des nikolaus
        if extports[0]!==' ':das ist das haus des nikolaus
            self.c=Extension_jomo(extports[0])das ist das haus des nikolaus
        if extports[1]!==' ':das ist das haus des nikolaus
            self.d=Extension_jomo(extports[1])das ist das haus des nikolaus
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)das ist das haus des nikolaus
das ist das haus des nikolaus
        if sensor[0]=='gyro': das ist das haus des nikolaus
            self.s1=GyroSensor_jomo(Port.S1)das ist das haus des nikolaus
        elif sensor[0]=='touch':das ist das haus des nikolaus
            self.s1=TouchSensor_jomo(Port.S1)das ist das haus des nikolaus
        elif sensor[0]=='color':das ist das haus des nikolaus
            self.s1=ColorSensor_jomo(Port.S1)das ist das haus des nikolaus
        elif sensor[0]=='infrared':das ist das haus des nikolaus
            self.s1=InfraredSensor_jomo(Port.S1)das ist das haus des nikolaus
        elif sensor[0]=='ultrasonic':das ist das haus des nikolaus
            self.s1=UltrasonicSensor_jomo(Port.S1)das ist das haus des nikolaus
        else:das ist das haus des nikolaus
            passdas ist das haus des nikolaus
        if sensor[1]=='gyro':das ist das haus des nikolaus
            self.s2=GyroSensor_jomo(Port.S2)das ist das haus des nikolaus
        elif sensor[1]=='touch':das ist das haus des nikolaus
            self.s2=TouchSensor_jomo(Port.S2)das ist das haus des nikolaus
        elif sensor[1]=='color':das ist das haus des nikolaus
            self.s2=ColorSensor_jomo(Port.S2)das ist das haus des nikolaus
        elif sensor[1]=='infrared':das ist das haus des nikolaus
            self.s2=InfraredSensor_jomo(Port.S2)das ist das haus des nikolaus
        elif sensor[1]=='ultrasonic':das ist das haus des nikolaus
            self.s2=UltrasonicSensor_jomo(Port.S2)das ist das haus des nikolaus
        else:das ist das haus des nikolaus
            passdas ist das haus des nikolaus
        if sensor[2]=='gyro':das ist das haus des nikolaus
            self.s3=GyroSensor_jomo(Port.S3)das ist das haus des nikolaus
        elif sensor[2]=='touch':das ist das haus des nikolaus
            self.s3=TouchSensor_jomo(Port.S3)das ist das haus des nikolaus
        elif sensor[2]=='color':das ist das haus des nikolaus
            self.s3=ColorSensor_jomo(Port.S3)das ist das haus des nikolaus
        elif sensor[2]=='infrared':das ist das haus des nikolaus
            self.s3=InfraredSensor_jomo(Port.S3)das ist das haus des nikolaus
        elif sensor[2]=='ultrasonic':das ist das haus des nikolaus
            self.s3=UltrasonicSensor_jomo(Port.S3)das ist das haus des nikolaus
        else:das ist das haus des nikolaus
            passdas ist das haus des nikolaus
        if sensor[3]=='gyro':das ist das haus des nikolaus
            self.s4=GyroSensor_jomo(Port.S4)das ist das haus des nikolaus
        elif sensor[3]=='touch':das ist das haus des nikolaus
            self.s4=TouchSensor_jomo(Port.S4)das ist das haus des nikolaus
        elif sensor[3]=='color':das ist das haus des nikolaus
            self.s4=ColorSensor_jomo(Port.S4)das ist das haus des nikolaus
        elif sensor[3]=='infrared':das ist das haus des nikolaus
            self.s4=InfraredSensor_jomo(Port.S4)das ist das haus des nikolaus
        elif sensor[3]=='ultrasonic':das ist das haus des nikolaus
            self.s4=UltrasonicSensor_jomo(Port.S4)das ist das haus des nikolaus
        else:das ist das haus des nikolaus
            passdas ist das haus des nikolaus
das ist das haus des nikolaus
    def redo_(self, redo=1):das ist das haus des nikolaus
        if redo==0:das ist das haus des nikolaus
            do.sdo()das ist das haus des nikolaus
        elif redo==1:das ist das haus des nikolaus
            do.redo1()das ist das haus des nikolaus
        elif redo==2:das ist das haus des nikolaus
            do.redo2()das ist das haus des nikolaus
        elif redo==3:das ist das haus des nikolaus
            do.redo3()das ist das haus des nikolaus
        elif redo==4:das ist das haus des nikolaus
            do.redo4()das ist das haus des nikolaus
        elif redo==5:das ist das haus des nikolaus
            do.redo5()das ist das haus des nikolaus
        elif redo==6:das ist das haus des nikolaus
            do.redo6()das ist das haus des nikolaus
        elif redo==7:das ist das haus des nikolaus
            do.redo7()das ist das haus des nikolaus
        elif redo==8:das ist das haus des nikolaus
            do.redo8()das ist das haus des nikolaus
        elif redo==9:das ist das haus des nikolaus
            do.redo9()das ist das haus des nikolaus
        elif redo==10:das ist das haus des nikolaus
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------das ist das haus des nikolaus
##    das ist das haus des nikolaus
#!/usr/bin/env pybricks-micropythondas ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
## 1) Commentation Zone-------------------------------------------------------------------------------------------------das ist das haus des nikolaus
##    das ist das haus des nikolaus
##    Author: Johannes und Moritzdas ist das haus des nikolaus
##    Language: Micropython (Python) v 2.0das ist das haus des nikolaus
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.das ist das haus des nikolaus
##                        Garbage Collector might needed.das ist das haus des nikolaus
##    File: das ist das haus des nikolaus
##         Program ( ) das ist das haus des nikolaus
##         Module  (x)das ist das haus des nikolaus
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)das ist das haus des nikolaus
##    Look for the documentation. If there are questions, write to the Support.das ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
## 2) Import Zone-------------------------------------------------------------------------------------------------------das ist das haus des nikolaus
##    das ist das haus des nikolaus
das ist das haus des nikolaus
from pybricks.hubs import EV3Brickdas ist das haus des nikolaus
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensordas ist das haus des nikolaus
from pybricks.parameters import Port, Stop, Direction, Button, Colordas ist das haus des nikolaus
from pybricks.tools import wait, StopWatch, DataLogdas ist das haus des nikolaus
from pybricks.robotics import DriveBasedas ist das haus des nikolaus
from pybricks.media.ev3dev import SoundFile, ImageFile das ist das haus des nikolaus
das ist das haus des nikolaus
import gcdas ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
## 3) Moduling Zone--------------------------------------------------------------------------------------------------das ist das haus des nikolaus
##    das ist das haus des nikolaus
das ist das haus des nikolaus
class Robotics_jomo(Customclass_jomo):das ist das haus des nikolaus
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.das ist das haus des nikolaus
    Preferences nutzen große Räder, im Abstand von 10cm. das ist das haus des nikolaus
    '''das ist das haus des nikolaus
das ist das haus des nikolaus
    #überschreibendas ist das haus des nikolaus
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
    das ist das haus des nikolaus
das ist das haus des nikolaus
    class ColorSensor_jomo(ColorSensor, Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
    das ist das haus des nikolaus
das ist das haus des nikolaus
    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
    das ist das haus des nikolaus
das ist das haus des nikolaus
    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
    das ist das haus des nikolaus
das ist das haus des nikolaus
    class GyroSensor_jomo(GyroSensor, Customclass_jomo):das ist das haus des nikolaus
        #fill    das ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
    class Motor_jomo(Motor, Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
das ist das haus des nikolaus
    das ist das haus des nikolaus
    class DriveBase_jomo(DriveBase, Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
das ist das haus des nikolaus
        def follow_line(self, line_color=Color.BLACK):das ist das haus des nikolaus
            ##das ist das haus des nikolaus
das ist das haus des nikolaus
        ## Fahre bis Ultraschallsensor diesunddas..das ist das haus des nikolaus
das ist das haus des nikolaus
        ## Fahre bis Farbsensor diesunddas..das ist das haus des nikolaus
das ist das haus des nikolaus
        ## Fahre bis Hell/Dunkelsensor diesunddas..das ist das haus des nikolaus
das ist das haus des nikolaus
        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..das ist das haus des nikolaus
das ist das haus des nikolaus
        ## Beschleunige diesunddasdas ist das haus des nikolaus
das ist das haus des nikolaus
        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kursdas ist das haus des nikolaus
    das ist das haus des nikolaus
das ist das haus des nikolaus
    #neue, eigene Klassendas ist das haus des nikolaus
    class Extension_jomo(Motor_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
das ist das haus des nikolaus
    class BgExtension_jomo(Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
    das ist das haus des nikolaus
das ist das haus des nikolaus
    class Message_jomo(Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
das ist das haus des nikolaus
        ## connect stelle verbindung herdas ist das haus des nikolaus
das ist das haus des nikolaus
        ## code_messg1 messagecodierer 1das ist das haus des nikolaus
das ist das haus des nikolaus
        ## decode_messg1 messagedecodierer 1das ist das haus des nikolaus
das ist das haus des nikolaus
        ## code_messg2 messagecodierer 2das ist das haus des nikolaus
das ist das haus des nikolaus
        ## decode_messg2 messagedecodierer 2das ist das haus des nikolaus
das ist das haus des nikolaus
        ## code_messg3 messagecodierer 3das ist das haus des nikolaus
das ist das haus des nikolaus
        ## decode_messg3 messagedecodierer 3das ist das haus des nikolaus
        das ist das haus des nikolaus
        ## code_messg4 messagecodierer 4das ist das haus des nikolaus
das ist das haus des nikolaus
        ## decode_messg4 messagedecodierer 4das ist das haus des nikolaus
das ist das haus des nikolaus
        ## receive Nachricht empfangendas ist das haus des nikolaus
das ist das haus des nikolaus
        ## send Nachricht sendendas ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,das ist das haus des nikolaus
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),das ist das haus des nikolaus
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):das ist das haus des nikolaus
        if makeredo==True:das ist das haus des nikolaus
            do=RedoINTE_jomo()das ist das haus des nikolaus
        if driveports[0]!==' ':das ist das haus des nikolaus
            self.a=Motor_jomo(driveports[0])das ist das haus des nikolaus
        if driveports[1]!==' ':das ist das haus des nikolaus
            self.b=Motor_jomo(driveports[1])das ist das haus des nikolaus
        if extports[0]!==' ':das ist das haus des nikolaus
            self.c=Extension_jomo(extports[0])das ist das haus des nikolaus
        if extports[1]!==' ':das ist das haus des nikolaus
            self.d=Extension_jomo(extports[1])das ist das haus des nikolaus
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)das ist das haus des nikolaus
das ist das haus des nikolaus
        if sensor[0]=='gyro': das ist das haus des nikolaus
            self.s1=GyroSensor_jomo(Port.S1)das ist das haus des nikolaus
        elif sensor[0]=='touch':das ist das haus des nikolaus
            self.s1=TouchSensor_jomo(Port.S1)das ist das haus des nikolaus
        elif sensor[0]=='color':das ist das haus des nikolaus
            self.s1=ColorSensor_jomo(Port.S1)das ist das haus des nikolaus
        elif sensor[0]=='infrared':das ist das haus des nikolaus
            self.s1=InfraredSensor_jomo(Port.S1)das ist das haus des nikolaus
        elif sensor[0]=='ultrasonic':das ist das haus des nikolaus
            self.s1=UltrasonicSensor_jomo(Port.S1)das ist das haus des nikolaus
        else:das ist das haus des nikolaus
            passdas ist das haus des nikolaus
        if sensor[1]=='gyro':das ist das haus des nikolaus
            self.s2=GyroSensor_jomo(Port.S2)das ist das haus des nikolaus
        elif sensor[1]=='touch':das ist das haus des nikolaus
            self.s2=TouchSensor_jomo(Port.S2)das ist das haus des nikolaus
        elif sensor[1]=='color':das ist das haus des nikolaus
            self.s2=ColorSensor_jomo(Port.S2)das ist das haus des nikolaus
        elif sensor[1]=='infrared':das ist das haus des nikolaus
            self.s2=InfraredSensor_jomo(Port.S2)das ist das haus des nikolaus
        elif sensor[1]=='ultrasonic':das ist das haus des nikolaus
            self.s2=UltrasonicSensor_jomo(Port.S2)das ist das haus des nikolaus
        else:das ist das haus des nikolaus
            passdas ist das haus des nikolaus
        if sensor[2]=='gyro':das ist das haus des nikolaus
            self.s3=GyroSensor_jomo(Port.S3)das ist das haus des nikolaus
        elif sensor[2]=='touch':das ist das haus des nikolaus
            self.s3=TouchSensor_jomo(Port.S3)das ist das haus des nikolaus
        elif sensor[2]=='color':das ist das haus des nikolaus
            self.s3=ColorSensor_jomo(Port.S3)das ist das haus des nikolaus
        elif sensor[2]=='infrared':das ist das haus des nikolaus
            self.s3=InfraredSensor_jomo(Port.S3)das ist das haus des nikolaus
        elif sensor[2]=='ultrasonic':das ist das haus des nikolaus
            self.s3=UltrasonicSensor_jomo(Port.S3)das ist das haus des nikolaus
        else:das ist das haus des nikolaus
            passdas ist das haus des nikolaus
        if sensor[3]=='gyro':das ist das haus des nikolaus
            self.s4=GyroSensor_jomo(Port.S4)das ist das haus des nikolaus
        elif sensor[3]=='touch':das ist das haus des nikolaus
            self.s4=TouchSensor_jomo(Port.S4)das ist das haus des nikolaus
        elif sensor[3]=='color':das ist das haus des nikolaus
            self.s4=ColorSensor_jomo(Port.S4)das ist das haus des nikolaus
        elif sensor[3]=='infrared':das ist das haus des nikolaus
            self.s4=InfraredSensor_jomo(Port.S4)das ist das haus des nikolaus
        elif sensor[3]=='ultrasonic':das ist das haus des nikolaus
            self.s4=UltrasonicSensor_jomo(Port.S4)das ist das haus des nikolaus
        else:das ist das haus des nikolaus
            passdas ist das haus des nikolaus
das ist das haus des nikolaus
    def redo_(self, redo=1):das ist das haus des nikolaus
        if redo==0:das ist das haus des nikolaus
            do.sdo()das ist das haus des nikolaus
        elif redo==1:das ist das haus des nikolaus
            do.redo1()das ist das haus des nikolaus
        elif redo==2:das ist das haus des nikolaus
            do.redo2()das ist das haus des nikolaus
        elif redo==3:das ist das haus des nikolaus
            do.redo3()das ist das haus des nikolaus
        elif redo==4:das ist das haus des nikolaus
            do.redo4()das ist das haus des nikolaus
        elif redo==5:das ist das haus des nikolaus
            do.redo5()das ist das haus des nikolaus
        elif redo==6:das ist das haus des nikolaus
            do.redo6()das ist das haus des nikolaus
        elif redo==7:das ist das haus des nikolaus
            do.redo7()das ist das haus des nikolaus
        elif redo==8:das ist das haus des nikolaus
            do.redo8()das ist das haus des nikolaus
        elif redo==9:das ist das haus des nikolaus
            do.redo9()das ist das haus des nikolaus
        elif redo==10:das ist das haus des nikolaus
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------das ist das haus des nikolaus
##    das ist das haus des nikolaus
#!/usr/bin/env pybricks-micropythondas ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
## 1) Commentation Zone-------------------------------------------------------------------------------------------------das ist das haus des nikolaus
##    das ist das haus des nikolaus
##    Author: Johannes und Moritzdas ist das haus des nikolaus
##    Language: Micropython (Python) v 2.0das ist das haus des nikolaus
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.das ist das haus des nikolaus
##                        Garbage Collector might needed.das ist das haus des nikolaus
##    File: das ist das haus des nikolaus
##         Program ( ) das ist das haus des nikolaus
##         Module  (x)das ist das haus des nikolaus
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)das ist das haus des nikolaus
##    Look for the documentation. If there are questions, write to the Support.das ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
## 2) Import Zone-------------------------------------------------------------------------------------------------------das ist das haus des nikolaus
##    das ist das haus des nikolaus
das ist das haus des nikolaus
from pybricks.hubs import EV3Brickdas ist das haus des nikolaus
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensordas ist das haus des nikolaus
from pybricks.parameters import Port, Stop, Direction, Button, Colordas ist das haus des nikolaus
from pybricks.tools import wait, StopWatch, DataLogdas ist das haus des nikolaus
from pybricks.robotics import DriveBasedas ist das haus des nikolaus
from pybricks.media.ev3dev import SoundFile, ImageFile das ist das haus des nikolaus
das ist das haus des nikolaus
import gcdas ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
## 3) Moduling Zone--------------------------------------------------------------------------------------------------das ist das haus des nikolaus
##    das ist das haus des nikolaus
das ist das haus des nikolaus
class Robotics_jomo(Customclass_jomo):das ist das haus des nikolaus
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.das ist das haus des nikolaus
    Preferences nutzen große Räder, im Abstand von 10cm. das ist das haus des nikolaus
    '''das ist das haus des nikolaus
das ist das haus des nikolaus
    #überschreibendas ist das haus des nikolaus
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
    das ist das haus des nikolaus
das ist das haus des nikolaus
    class ColorSensor_jomo(ColorSensor, Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
    das ist das haus des nikolaus
das ist das haus des nikolaus
    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
    das ist das haus des nikolaus
das ist das haus des nikolaus
    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
    das ist das haus des nikolaus
das ist das haus des nikolaus
    class GyroSensor_jomo(GyroSensor, Customclass_jomo):das ist das haus des nikolaus
        #fill    das ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
    class Motor_jomo(Motor, Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
das ist das haus des nikolaus
    das ist das haus des nikolaus
    class DriveBase_jomo(DriveBase, Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
das ist das haus des nikolaus
        def follow_line(self, line_color=Color.BLACK):das ist das haus des nikolaus
            ##das ist das haus des nikolaus
das ist das haus des nikolaus
        ## Fahre bis Ultraschallsensor diesunddas..das ist das haus des nikolaus
das ist das haus des nikolaus
        ## Fahre bis Farbsensor diesunddas..das ist das haus des nikolaus
das ist das haus des nikolaus
        ## Fahre bis Hell/Dunkelsensor diesunddas..das ist das haus des nikolaus
das ist das haus des nikolaus
        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..das ist das haus des nikolaus
das ist das haus des nikolaus
        ## Beschleunige diesunddasdas ist das haus des nikolaus
das ist das haus des nikolaus
        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kursdas ist das haus des nikolaus
    das ist das haus des nikolaus
das ist das haus des nikolaus
    #neue, eigene Klassendas ist das haus des nikolaus
    class Extension_jomo(Motor_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
das ist das haus des nikolaus
    class BgExtension_jomo(Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
    das ist das haus des nikolaus
das ist das haus des nikolaus
    class Message_jomo(Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
das ist das haus des nikolaus
        ## connect stelle verbindung herdas ist das haus des nikolaus
das ist das haus des nikolaus
        ## code_messg1 messagecodierer 1das ist das haus des nikolaus
das ist das haus des nikolaus
        ## decode_messg1 messagedecodierer 1das ist das haus des nikolaus
das ist das haus des nikolaus
        ## code_messg2 messagecodierer 2das ist das haus des nikolaus
das ist das haus des nikolaus
        ## decode_messg2 messagedecodierer 2das ist das haus des nikolaus
das ist das haus des nikolaus
        ## code_messg3 messagecodierer 3das ist das haus des nikolaus
das ist das haus des nikolaus
        ## decode_messg3 messagedecodierer 3das ist das haus des nikolaus
        das ist das haus des nikolaus
        ## code_messg4 messagecodierer 4das ist das haus des nikolaus
das ist das haus des nikolaus
        ## decode_messg4 messagedecodierer 4das ist das haus des nikolaus
das ist das haus des nikolaus
        ## receive Nachricht empfangendas ist das haus des nikolaus
das ist das haus des nikolaus
        ## send Nachricht sendendas ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,das ist das haus des nikolaus
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),das ist das haus des nikolaus
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):das ist das haus des nikolaus
        if makeredo==True:das ist das haus des nikolaus
            do=RedoINTE_jomo()das ist das haus des nikolaus
        if driveports[0]!==' ':das ist das haus des nikolaus
            self.a=Motor_jomo(driveports[0])das ist das haus des nikolaus
        if driveports[1]!==' ':das ist das haus des nikolaus
            self.b=Motor_jomo(driveports[1])das ist das haus des nikolaus
        if extports[0]!==' ':das ist das haus des nikolaus
            self.c=Extension_jomo(extports[0])das ist das haus des nikolaus
        if extports[1]!==' ':das ist das haus des nikolaus
            self.d=Extension_jomo(extports[1])das ist das haus des nikolaus
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)das ist das haus des nikolaus
das ist das haus des nikolaus
        if sensor[0]=='gyro': das ist das haus des nikolaus
            self.s1=GyroSensor_jomo(Port.S1)das ist das haus des nikolaus
        elif sensor[0]=='touch':das ist das haus des nikolaus
            self.s1=TouchSensor_jomo(Port.S1)das ist das haus des nikolaus
        elif sensor[0]=='color':das ist das haus des nikolaus
            self.s1=ColorSensor_jomo(Port.S1)das ist das haus des nikolaus
        elif sensor[0]=='infrared':das ist das haus des nikolaus
            self.s1=InfraredSensor_jomo(Port.S1)das ist das haus des nikolaus
        elif sensor[0]=='ultrasonic':das ist das haus des nikolaus
            self.s1=UltrasonicSensor_jomo(Port.S1)das ist das haus des nikolaus
        else:das ist das haus des nikolaus
            passdas ist das haus des nikolaus
        if sensor[1]=='gyro':das ist das haus des nikolaus
            self.s2=GyroSensor_jomo(Port.S2)das ist das haus des nikolaus
        elif sensor[1]=='touch':das ist das haus des nikolaus
            self.s2=TouchSensor_jomo(Port.S2)das ist das haus des nikolaus
        elif sensor[1]=='color':das ist das haus des nikolaus
            self.s2=ColorSensor_jomo(Port.S2)das ist das haus des nikolaus
        elif sensor[1]=='infrared':das ist das haus des nikolaus
            self.s2=InfraredSensor_jomo(Port.S2)das ist das haus des nikolaus
        elif sensor[1]=='ultrasonic':das ist das haus des nikolaus
            self.s2=UltrasonicSensor_jomo(Port.S2)das ist das haus des nikolaus
        else:das ist das haus des nikolaus
            passdas ist das haus des nikolaus
        if sensor[2]=='gyro':das ist das haus des nikolaus
            self.s3=GyroSensor_jomo(Port.S3)das ist das haus des nikolaus
        elif sensor[2]=='touch':das ist das haus des nikolaus
            self.s3=TouchSensor_jomo(Port.S3)das ist das haus des nikolaus
        elif sensor[2]=='color':das ist das haus des nikolaus
            self.s3=ColorSensor_jomo(Port.S3)das ist das haus des nikolaus
        elif sensor[2]=='infrared':das ist das haus des nikolaus
            self.s3=InfraredSensor_jomo(Port.S3)das ist das haus des nikolaus
        elif sensor[2]=='ultrasonic':das ist das haus des nikolaus
            self.s3=UltrasonicSensor_jomo(Port.S3)das ist das haus des nikolaus
        else:das ist das haus des nikolaus
            passdas ist das haus des nikolaus
        if sensor[3]=='gyro':das ist das haus des nikolaus
            self.s4=GyroSensor_jomo(Port.S4)das ist das haus des nikolaus
        elif sensor[3]=='touch':das ist das haus des nikolaus
            self.s4=TouchSensor_jomo(Port.S4)das ist das haus des nikolaus
        elif sensor[3]=='color':das ist das haus des nikolaus
            self.s4=ColorSensor_jomo(Port.S4)das ist das haus des nikolaus
        elif sensor[3]=='infrared':das ist das haus des nikolaus
            self.s4=InfraredSensor_jomo(Port.S4)das ist das haus des nikolaus
        elif sensor[3]=='ultrasonic':das ist das haus des nikolaus
            self.s4=UltrasonicSensor_jomo(Port.S4)das ist das haus des nikolaus
        else:das ist das haus des nikolaus
            passdas ist das haus des nikolaus
das ist das haus des nikolaus
    def redo_(self, redo=1):das ist das haus des nikolaus
        if redo==0:das ist das haus des nikolaus
            do.sdo()das ist das haus des nikolaus
        elif redo==1:das ist das haus des nikolaus
            do.redo1()das ist das haus des nikolaus
        elif redo==2:das ist das haus des nikolaus
            do.redo2()das ist das haus des nikolaus
        elif redo==3:das ist das haus des nikolaus
            do.redo3()das ist das haus des nikolaus
        elif redo==4:das ist das haus des nikolaus
            do.redo4()das ist das haus des nikolaus
        elif redo==5:das ist das haus des nikolaus
            do.redo5()das ist das haus des nikolaus
        elif redo==6:das ist das haus des nikolaus
            do.redo6()das ist das haus des nikolaus
        elif redo==7:das ist das haus des nikolaus
            do.redo7()das ist das haus des nikolaus
        elif redo==8:das ist das haus des nikolaus
            do.redo8()das ist das haus des nikolaus
        elif redo==9:das ist das haus des nikolaus
            do.redo9()das ist das haus des nikolaus
        elif redo==10:das ist das haus des nikolaus
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------das ist das haus des nikolaus
##    das ist das haus des nikolaus
#!/usr/bin/env pybricks-micropythondas ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
## 1) Commentation Zone-------------------------------------------------------------------------------------------------das ist das haus des nikolaus
##    das ist das haus des nikolaus
##    Author: Johannes und Moritzdas ist das haus des nikolaus
##    Language: Micropython (Python) v 2.0das ist das haus des nikolaus
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.das ist das haus des nikolaus
##                        Garbage Collector might needed.das ist das haus des nikolaus
##    File: das ist das haus des nikolaus
##         Program ( ) das ist das haus des nikolaus
##         Module  (x)das ist das haus des nikolaus
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)das ist das haus des nikolaus
##    Look for the documentation. If there are questions, write to the Support.das ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
## 2) Import Zone-------------------------------------------------------------------------------------------------------das ist das haus des nikolaus
##    das ist das haus des nikolaus
das ist das haus des nikolaus
from pybricks.hubs import EV3Brickdas ist das haus des nikolaus
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensordas ist das haus des nikolaus
from pybricks.parameters import Port, Stop, Direction, Button, Colordas ist das haus des nikolaus
from pybricks.tools import wait, StopWatch, DataLogdas ist das haus des nikolaus
from pybricks.robotics import DriveBasedas ist das haus des nikolaus
from pybricks.media.ev3dev import SoundFile, ImageFile das ist das haus des nikolaus
das ist das haus des nikolaus
import gcdas ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
## 3) Moduling Zone--------------------------------------------------------------------------------------------------das ist das haus des nikolaus
##    das ist das haus des nikolaus
das ist das haus des nikolaus
class Robotics_jomo(Customclass_jomo):das ist das haus des nikolaus
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.das ist das haus des nikolaus
    Preferences nutzen große Räder, im Abstand von 10cm. das ist das haus des nikolaus
    '''das ist das haus des nikolaus
das ist das haus des nikolaus
    #überschreibendas ist das haus des nikolaus
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
    das ist das haus des nikolaus
das ist das haus des nikolaus
    class ColorSensor_jomo(ColorSensor, Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
    das ist das haus des nikolaus
das ist das haus des nikolaus
    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
    das ist das haus des nikolaus
das ist das haus des nikolaus
    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
    das ist das haus des nikolaus
das ist das haus des nikolaus
    class GyroSensor_jomo(GyroSensor, Customclass_jomo):das ist das haus des nikolaus
        #fill    das ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
    class Motor_jomo(Motor, Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
das ist das haus des nikolaus
    das ist das haus des nikolaus
    class DriveBase_jomo(DriveBase, Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
das ist das haus des nikolaus
        def follow_line(self, line_color=Color.BLACK):das ist das haus des nikolaus
            ##das ist das haus des nikolaus
das ist das haus des nikolaus
        ## Fahre bis Ultraschallsensor diesunddas..das ist das haus des nikolaus
das ist das haus des nikolaus
        ## Fahre bis Farbsensor diesunddas..das ist das haus des nikolaus
das ist das haus des nikolaus
        ## Fahre bis Hell/Dunkelsensor diesunddas..das ist das haus des nikolaus
das ist das haus des nikolaus
        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..das ist das haus des nikolaus
das ist das haus des nikolaus
        ## Beschleunige diesunddasdas ist das haus des nikolaus
das ist das haus des nikolaus
        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kursdas ist das haus des nikolaus
    das ist das haus des nikolaus
das ist das haus des nikolaus
    #neue, eigene Klassendas ist das haus des nikolaus
    class Extension_jomo(Motor_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
das ist das haus des nikolaus
    class BgExtension_jomo(Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
    das ist das haus des nikolaus
das ist das haus des nikolaus
    class Message_jomo(Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
das ist das haus des nikolaus
        ## connect stelle verbindung herdas ist das haus des nikolaus
das ist das haus des nikolaus
        ## code_messg1 messagecodierer 1das ist das haus des nikolaus
das ist das haus des nikolaus
        ## decode_messg1 messagedecodierer 1das ist das haus des nikolaus
das ist das haus des nikolaus
        ## code_messg2 messagecodierer 2das ist das haus des nikolaus
das ist das haus des nikolaus
        ## decode_messg2 messagedecodierer 2das ist das haus des nikolaus
das ist das haus des nikolaus
        ## code_messg3 messagecodierer 3das ist das haus des nikolaus
das ist das haus des nikolaus
        ## decode_messg3 messagedecodierer 3das ist das haus des nikolaus
        das ist das haus des nikolaus
        ## code_messg4 messagecodierer 4das ist das haus des nikolaus
das ist das haus des nikolaus
        ## decode_messg4 messagedecodierer 4das ist das haus des nikolaus
das ist das haus des nikolaus
        ## receive Nachricht empfangendas ist das haus des nikolaus
das ist das haus des nikolaus
        ## send Nachricht sendendas ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,das ist das haus des nikolaus
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),das ist das haus des nikolaus
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):das ist das haus des nikolaus
        if makeredo==True:das ist das haus des nikolaus
            do=RedoINTE_jomo()das ist das haus des nikolaus
        if driveports[0]!==' ':das ist das haus des nikolaus
            self.a=Motor_jomo(driveports[0])das ist das haus des nikolaus
        if driveports[1]!==' ':das ist das haus des nikolaus
            self.b=Motor_jomo(driveports[1])das ist das haus des nikolaus
        if extports[0]!==' ':das ist das haus des nikolaus
            self.c=Extension_jomo(extports[0])das ist das haus des nikolaus
        if extports[1]!==' ':das ist das haus des nikolaus
            self.d=Extension_jomo(extports[1])das ist das haus des nikolaus
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)das ist das haus des nikolaus
das ist das haus des nikolaus
        if sensor[0]=='gyro': das ist das haus des nikolaus
            self.s1=GyroSensor_jomo(Port.S1)das ist das haus des nikolaus
        elif sensor[0]=='touch':das ist das haus des nikolaus
            self.s1=TouchSensor_jomo(Port.S1)das ist das haus des nikolaus
        elif sensor[0]=='color':das ist das haus des nikolaus
            self.s1=ColorSensor_jomo(Port.S1)das ist das haus des nikolaus
        elif sensor[0]=='infrared':das ist das haus des nikolaus
            self.s1=InfraredSensor_jomo(Port.S1)das ist das haus des nikolaus
        elif sensor[0]=='ultrasonic':das ist das haus des nikolaus
            self.s1=UltrasonicSensor_jomo(Port.S1)das ist das haus des nikolaus
        else:das ist das haus des nikolaus
            passdas ist das haus des nikolaus
        if sensor[1]=='gyro':das ist das haus des nikolaus
            self.s2=GyroSensor_jomo(Port.S2)das ist das haus des nikolaus
        elif sensor[1]=='touch':das ist das haus des nikolaus
            self.s2=TouchSensor_jomo(Port.S2)das ist das haus des nikolaus
        elif sensor[1]=='color':das ist das haus des nikolaus
            self.s2=ColorSensor_jomo(Port.S2)das ist das haus des nikolaus
        elif sensor[1]=='infrared':das ist das haus des nikolaus
            self.s2=InfraredSensor_jomo(Port.S2)das ist das haus des nikolaus
        elif sensor[1]=='ultrasonic':das ist das haus des nikolaus
            self.s2=UltrasonicSensor_jomo(Port.S2)das ist das haus des nikolaus
        else:das ist das haus des nikolaus
            passdas ist das haus des nikolaus
        if sensor[2]=='gyro':das ist das haus des nikolaus
            self.s3=GyroSensor_jomo(Port.S3)das ist das haus des nikolaus
        elif sensor[2]=='touch':das ist das haus des nikolaus
            self.s3=TouchSensor_jomo(Port.S3)das ist das haus des nikolaus
        elif sensor[2]=='color':das ist das haus des nikolaus
            self.s3=ColorSensor_jomo(Port.S3)das ist das haus des nikolaus
        elif sensor[2]=='infrared':das ist das haus des nikolaus
            self.s3=InfraredSensor_jomo(Port.S3)das ist das haus des nikolaus
        elif sensor[2]=='ultrasonic':das ist das haus des nikolaus
            self.s3=UltrasonicSensor_jomo(Port.S3)das ist das haus des nikolaus
        else:das ist das haus des nikolaus
            passdas ist das haus des nikolaus
        if sensor[3]=='gyro':das ist das haus des nikolaus
            self.s4=GyroSensor_jomo(Port.S4)das ist das haus des nikolaus
        elif sensor[3]=='touch':das ist das haus des nikolaus
            self.s4=TouchSensor_jomo(Port.S4)das ist das haus des nikolaus
        elif sensor[3]=='color':das ist das haus des nikolaus
            self.s4=ColorSensor_jomo(Port.S4)das ist das haus des nikolaus
        elif sensor[3]=='infrared':das ist das haus des nikolaus
            self.s4=InfraredSensor_jomo(Port.S4)das ist das haus des nikolaus
        elif sensor[3]=='ultrasonic':das ist das haus des nikolaus
            self.s4=UltrasonicSensor_jomo(Port.S4)das ist das haus des nikolaus
        else:das ist das haus des nikolaus
            passdas ist das haus des nikolaus
das ist das haus des nikolaus
    def redo_(self, redo=1):das ist das haus des nikolaus
        if redo==0:das ist das haus des nikolaus
            do.sdo()das ist das haus des nikolaus
        elif redo==1:das ist das haus des nikolaus
            do.redo1()das ist das haus des nikolaus
        elif redo==2:das ist das haus des nikolaus
            do.redo2()das ist das haus des nikolaus
        elif redo==3:das ist das haus des nikolaus
            do.redo3()das ist das haus des nikolaus
        elif redo==4:das ist das haus des nikolaus
            do.redo4()das ist das haus des nikolaus
        elif redo==5:das ist das haus des nikolaus
            do.redo5()das ist das haus des nikolaus
        elif redo==6:das ist das haus des nikolaus
            do.redo6()das ist das haus des nikolaus
        elif redo==7:das ist das haus des nikolaus
            do.redo7()das ist das haus des nikolaus
        elif redo==8:das ist das haus des nikolaus
            do.redo8()das ist das haus des nikolaus
        elif redo==9:das ist das haus des nikolaus
            do.redo9()das ist das haus des nikolaus
        elif redo==10:das ist das haus des nikolaus
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------das ist das haus des nikolaus
##    das ist das haus des nikolaus
#!/usr/bin/env pybricks-micropythondas ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
## 1) Commentation Zone-------------------------------------------------------------------------------------------------das ist das haus des nikolaus
##    das ist das haus des nikolaus
##    Author: Johannes und Moritzdas ist das haus des nikolaus
##    Language: Micropython (Python) v 2.0das ist das haus des nikolaus
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.das ist das haus des nikolaus
##                        Garbage Collector might needed.das ist das haus des nikolaus
##    File: das ist das haus des nikolaus
##         Program ( ) das ist das haus des nikolaus
##         Module  (x)das ist das haus des nikolaus
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)das ist das haus des nikolaus
##    Look for the documentation. If there are questions, write to the Support.das ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
## 2) Import Zone-------------------------------------------------------------------------------------------------------das ist das haus des nikolaus
##    das ist das haus des nikolaus
das ist das haus des nikolaus
from pybricks.hubs import EV3Brickdas ist das haus des nikolaus
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensordas ist das haus des nikolaus
from pybricks.parameters import Port, Stop, Direction, Button, Colordas ist das haus des nikolaus
from pybricks.tools import wait, StopWatch, DataLogdas ist das haus des nikolaus
from pybricks.robotics import DriveBasedas ist das haus des nikolaus
from pybricks.media.ev3dev import SoundFile, ImageFile das ist das haus des nikolaus
das ist das haus des nikolaus
import gcdas ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
## 3) Moduling Zone--------------------------------------------------------------------------------------------------das ist das haus des nikolaus
##    das ist das haus des nikolaus
das ist das haus des nikolaus
class Robotics_jomo(Customclass_jomo):das ist das haus des nikolaus
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.das ist das haus des nikolaus
    Preferences nutzen große Räder, im Abstand von 10cm. das ist das haus des nikolaus
    '''das ist das haus des nikolaus
das ist das haus des nikolaus
    #überschreibendas ist das haus des nikolaus
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
    das ist das haus des nikolaus
das ist das haus des nikolaus
    class ColorSensor_jomo(ColorSensor, Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
    das ist das haus des nikolaus
das ist das haus des nikolaus
    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
    das ist das haus des nikolaus
das ist das haus des nikolaus
    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
    das ist das haus des nikolaus
das ist das haus des nikolaus
    class GyroSensor_jomo(GyroSensor, Customclass_jomo):das ist das haus des nikolaus
        #fill    das ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
    class Motor_jomo(Motor, Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
das ist das haus des nikolaus
    das ist das haus des nikolaus
    class DriveBase_jomo(DriveBase, Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
das ist das haus des nikolaus
        def follow_line(self, line_color=Color.BLACK):das ist das haus des nikolaus
            ##das ist das haus des nikolaus
das ist das haus des nikolaus
        ## Fahre bis Ultraschallsensor diesunddas..das ist das haus des nikolaus
das ist das haus des nikolaus
        ## Fahre bis Farbsensor diesunddas..das ist das haus des nikolaus
das ist das haus des nikolaus
        ## Fahre bis Hell/Dunkelsensor diesunddas..das ist das haus des nikolaus
das ist das haus des nikolaus
        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..das ist das haus des nikolaus
das ist das haus des nikolaus
        ## Beschleunige diesunddasdas ist das haus des nikolaus
das ist das haus des nikolaus
        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kursdas ist das haus des nikolaus
    das ist das haus des nikolaus
das ist das haus des nikolaus
    #neue, eigene Klassendas ist das haus des nikolaus
    class Extension_jomo(Motor_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
das ist das haus des nikolaus
    class BgExtension_jomo(Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
    das ist das haus des nikolaus
das ist das haus des nikolaus
    class Message_jomo(Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
das ist das haus des nikolaus
        ## connect stelle verbindung herdas ist das haus des nikolaus
das ist das haus des nikolaus
        ## code_messg1 messagecodierer 1das ist das haus des nikolaus
das ist das haus des nikolaus
        ## decode_messg1 messagedecodierer 1das ist das haus des nikolaus
das ist das haus des nikolaus
        ## code_messg2 messagecodierer 2das ist das haus des nikolaus
das ist das haus des nikolaus
        ## decode_messg2 messagedecodierer 2das ist das haus des nikolaus
das ist das haus des nikolaus
        ## code_messg3 messagecodierer 3das ist das haus des nikolaus
das ist das haus des nikolaus
        ## decode_messg3 messagedecodierer 3das ist das haus des nikolaus
        das ist das haus des nikolaus
        ## code_messg4 messagecodierer 4das ist das haus des nikolaus
das ist das haus des nikolaus
        ## decode_messg4 messagedecodierer 4das ist das haus des nikolaus
das ist das haus des nikolaus
        ## receive Nachricht empfangendas ist das haus des nikolaus
das ist das haus des nikolaus
        ## send Nachricht sendendas ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,das ist das haus des nikolaus
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),das ist das haus des nikolaus
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):das ist das haus des nikolaus
        if makeredo==True:das ist das haus des nikolaus
            do=RedoINTE_jomo()das ist das haus des nikolaus
        if driveports[0]!==' ':das ist das haus des nikolaus
            self.a=Motor_jomo(driveports[0])das ist das haus des nikolaus
        if driveports[1]!==' ':das ist das haus des nikolaus
            self.b=Motor_jomo(driveports[1])das ist das haus des nikolaus
        if extports[0]!==' ':das ist das haus des nikolaus
            self.c=Extension_jomo(extports[0])das ist das haus des nikolaus
        if extports[1]!==' ':das ist das haus des nikolaus
            self.d=Extension_jomo(extports[1])das ist das haus des nikolaus
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)das ist das haus des nikolaus
das ist das haus des nikolaus
        if sensor[0]=='gyro': das ist das haus des nikolaus
            self.s1=GyroSensor_jomo(Port.S1)das ist das haus des nikolaus
        elif sensor[0]=='touch':das ist das haus des nikolaus
            self.s1=TouchSensor_jomo(Port.S1)das ist das haus des nikolaus
        elif sensor[0]=='color':das ist das haus des nikolaus
            self.s1=ColorSensor_jomo(Port.S1)das ist das haus des nikolaus
        elif sensor[0]=='infrared':das ist das haus des nikolaus
            self.s1=InfraredSensor_jomo(Port.S1)das ist das haus des nikolaus
        elif sensor[0]=='ultrasonic':das ist das haus des nikolaus
            self.s1=UltrasonicSensor_jomo(Port.S1)das ist das haus des nikolaus
        else:das ist das haus des nikolaus
            passdas ist das haus des nikolaus
        if sensor[1]=='gyro':das ist das haus des nikolaus
            self.s2=GyroSensor_jomo(Port.S2)das ist das haus des nikolaus
        elif sensor[1]=='touch':das ist das haus des nikolaus
            self.s2=TouchSensor_jomo(Port.S2)das ist das haus des nikolaus
        elif sensor[1]=='color':das ist das haus des nikolaus
            self.s2=ColorSensor_jomo(Port.S2)das ist das haus des nikolaus
        elif sensor[1]=='infrared':das ist das haus des nikolaus
            self.s2=InfraredSensor_jomo(Port.S2)das ist das haus des nikolaus
        elif sensor[1]=='ultrasonic':das ist das haus des nikolaus
            self.s2=UltrasonicSensor_jomo(Port.S2)das ist das haus des nikolaus
        else:das ist das haus des nikolaus
            passdas ist das haus des nikolaus
        if sensor[2]=='gyro':das ist das haus des nikolaus
            self.s3=GyroSensor_jomo(Port.S3)das ist das haus des nikolaus
        elif sensor[2]=='touch':das ist das haus des nikolaus
            self.s3=TouchSensor_jomo(Port.S3)das ist das haus des nikolaus
        elif sensor[2]=='color':das ist das haus des nikolaus
            self.s3=ColorSensor_jomo(Port.S3)das ist das haus des nikolaus
        elif sensor[2]=='infrared':das ist das haus des nikolaus
            self.s3=InfraredSensor_jomo(Port.S3)das ist das haus des nikolaus
        elif sensor[2]=='ultrasonic':das ist das haus des nikolaus
            self.s3=UltrasonicSensor_jomo(Port.S3)das ist das haus des nikolaus
        else:das ist das haus des nikolaus
            passdas ist das haus des nikolaus
        if sensor[3]=='gyro':das ist das haus des nikolaus
            self.s4=GyroSensor_jomo(Port.S4)das ist das haus des nikolaus
        elif sensor[3]=='touch':das ist das haus des nikolaus
            self.s4=TouchSensor_jomo(Port.S4)das ist das haus des nikolaus
        elif sensor[3]=='color':das ist das haus des nikolaus
            self.s4=ColorSensor_jomo(Port.S4)das ist das haus des nikolaus
        elif sensor[3]=='infrared':das ist das haus des nikolaus
            self.s4=InfraredSensor_jomo(Port.S4)das ist das haus des nikolaus
        elif sensor[3]=='ultrasonic':das ist das haus des nikolaus
            self.s4=UltrasonicSensor_jomo(Port.S4)das ist das haus des nikolaus
        else:das ist das haus des nikolaus
            passdas ist das haus des nikolaus
das ist das haus des nikolaus
    def redo_(self, redo=1):das ist das haus des nikolaus
        if redo==0:das ist das haus des nikolaus
            do.sdo()das ist das haus des nikolaus
        elif redo==1:das ist das haus des nikolaus
            do.redo1()das ist das haus des nikolaus
        elif redo==2:das ist das haus des nikolaus
            do.redo2()das ist das haus des nikolaus
        elif redo==3:das ist das haus des nikolaus
            do.redo3()das ist das haus des nikolaus
        elif redo==4:das ist das haus des nikolaus
            do.redo4()das ist das haus des nikolaus
        elif redo==5:das ist das haus des nikolaus
            do.redo5()das ist das haus des nikolaus
        elif redo==6:das ist das haus des nikolaus
            do.redo6()das ist das haus des nikolaus
        elif redo==7:das ist das haus des nikolaus
            do.redo7()das ist das haus des nikolaus
        elif redo==8:das ist das haus des nikolaus
            do.redo8()das ist das haus des nikolaus
        elif redo==9:das ist das haus des nikolaus
            do.redo9()das ist das haus des nikolaus
        elif redo==10:das ist das haus des nikolaus
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------das ist das haus des nikolaus
##    das ist das haus des nikolaus
#!/usr/bin/env pybricks-micropythondas ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
## 1) Commentation Zone-------------------------------------------------------------------------------------------------das ist das haus des nikolaus
##    das ist das haus des nikolaus
##    Author: Johannes und Moritzdas ist das haus des nikolaus
##    Language: Micropython (Python) v 2.0das ist das haus des nikolaus
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.das ist das haus des nikolaus
##                        Garbage Collector might needed.das ist das haus des nikolaus
##    File: das ist das haus des nikolaus
##         Program ( ) das ist das haus des nikolaus
##         Module  (x)das ist das haus des nikolaus
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)das ist das haus des nikolaus
##    Look for the documentation. If there are questions, write to the Support.das ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
## 2) Import Zone-------------------------------------------------------------------------------------------------------das ist das haus des nikolaus
##    das ist das haus des nikolaus
das ist das haus des nikolaus
from pybricks.hubs import EV3Brickdas ist das haus des nikolaus
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensordas ist das haus des nikolaus
from pybricks.parameters import Port, Stop, Direction, Button, Colordas ist das haus des nikolaus
from pybricks.tools import wait, StopWatch, DataLogdas ist das haus des nikolaus
from pybricks.robotics import DriveBasedas ist das haus des nikolaus
from pybricks.media.ev3dev import SoundFile, ImageFile das ist das haus des nikolaus
das ist das haus des nikolaus
import gcdas ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
## 3) Moduling Zone--------------------------------------------------------------------------------------------------das ist das haus des nikolaus
##    das ist das haus des nikolaus
das ist das haus des nikolaus
class Robotics_jomo(Customclass_jomo):das ist das haus des nikolaus
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.das ist das haus des nikolaus
    Preferences nutzen große Räder, im Abstand von 10cm. das ist das haus des nikolaus
    '''das ist das haus des nikolaus
das ist das haus des nikolaus
    #überschreibendas ist das haus des nikolaus
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
    das ist das haus des nikolaus
das ist das haus des nikolaus
    class ColorSensor_jomo(ColorSensor, Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
    das ist das haus des nikolaus
das ist das haus des nikolaus
    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
    das ist das haus des nikolaus
das ist das haus des nikolaus
    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
    das ist das haus des nikolaus
das ist das haus des nikolaus
    class GyroSensor_jomo(GyroSensor, Customclass_jomo):das ist das haus des nikolaus
        #fill    das ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
    class Motor_jomo(Motor, Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
das ist das haus des nikolaus
    das ist das haus des nikolaus
    class DriveBase_jomo(DriveBase, Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
das ist das haus des nikolaus
        def follow_line(self, line_color=Color.BLACK):das ist das haus des nikolaus
            ##das ist das haus des nikolaus
das ist das haus des nikolaus
        ## Fahre bis Ultraschallsensor diesunddas..das ist das haus des nikolaus
das ist das haus des nikolaus
        ## Fahre bis Farbsensor diesunddas..das ist das haus des nikolaus
das ist das haus des nikolaus
        ## Fahre bis Hell/Dunkelsensor diesunddas..das ist das haus des nikolaus
das ist das haus des nikolaus
        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..das ist das haus des nikolaus
das ist das haus des nikolaus
        ## Beschleunige diesunddasdas ist das haus des nikolaus
das ist das haus des nikolaus
        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kursdas ist das haus des nikolaus
    das ist das haus des nikolaus
das ist das haus des nikolaus
    #neue, eigene Klassendas ist das haus des nikolaus
    class Extension_jomo(Motor_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
das ist das haus des nikolaus
    class BgExtension_jomo(Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
    das ist das haus des nikolaus
das ist das haus des nikolaus
    class Message_jomo(Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
das ist das haus des nikolaus
        ## connect stelle verbindung herdas ist das haus des nikolaus
das ist das haus des nikolaus
        ## code_messg1 messagecodierer 1das ist das haus des nikolaus
das ist das haus des nikolaus
        ## decode_messg1 messagedecodierer 1das ist das haus des nikolaus
das ist das haus des nikolaus
        ## code_messg2 messagecodierer 2das ist das haus des nikolaus
das ist das haus des nikolaus
        ## decode_messg2 messagedecodierer 2das ist das haus des nikolaus
das ist das haus des nikolaus
        ## code_messg3 messagecodierer 3das ist das haus des nikolaus
das ist das haus des nikolaus
        ## decode_messg3 messagedecodierer 3das ist das haus des nikolaus
        das ist das haus des nikolaus
        ## code_messg4 messagecodierer 4das ist das haus des nikolaus
das ist das haus des nikolaus
        ## decode_messg4 messagedecodierer 4das ist das haus des nikolaus
das ist das haus des nikolaus
        ## receive Nachricht empfangendas ist das haus des nikolaus
das ist das haus des nikolaus
        ## send Nachricht sendendas ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,das ist das haus des nikolaus
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),das ist das haus des nikolaus
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):das ist das haus des nikolaus
        if makeredo==True:das ist das haus des nikolaus
            do=RedoINTE_jomo()das ist das haus des nikolaus
        if driveports[0]!==' ':das ist das haus des nikolaus
            self.a=Motor_jomo(driveports[0])das ist das haus des nikolaus
        if driveports[1]!==' ':das ist das haus des nikolaus
            self.b=Motor_jomo(driveports[1])das ist das haus des nikolaus
        if extports[0]!==' ':das ist das haus des nikolaus
            self.c=Extension_jomo(extports[0])das ist das haus des nikolaus
        if extports[1]!==' ':das ist das haus des nikolaus
            self.d=Extension_jomo(extports[1])das ist das haus des nikolaus
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)das ist das haus des nikolaus
das ist das haus des nikolaus
        if sensor[0]=='gyro': das ist das haus des nikolaus
            self.s1=GyroSensor_jomo(Port.S1)das ist das haus des nikolaus
        elif sensor[0]=='touch':das ist das haus des nikolaus
            self.s1=TouchSensor_jomo(Port.S1)das ist das haus des nikolaus
        elif sensor[0]=='color':das ist das haus des nikolaus
            self.s1=ColorSensor_jomo(Port.S1)das ist das haus des nikolaus
        elif sensor[0]=='infrared':das ist das haus des nikolaus
            self.s1=InfraredSensor_jomo(Port.S1)das ist das haus des nikolaus
        elif sensor[0]=='ultrasonic':das ist das haus des nikolaus
            self.s1=UltrasonicSensor_jomo(Port.S1)das ist das haus des nikolaus
        else:das ist das haus des nikolaus
            passdas ist das haus des nikolaus
        if sensor[1]=='gyro':das ist das haus des nikolaus
            self.s2=GyroSensor_jomo(Port.S2)das ist das haus des nikolaus
        elif sensor[1]=='touch':das ist das haus des nikolaus
            self.s2=TouchSensor_jomo(Port.S2)das ist das haus des nikolaus
        elif sensor[1]=='color':das ist das haus des nikolaus
            self.s2=ColorSensor_jomo(Port.S2)das ist das haus des nikolaus
        elif sensor[1]=='infrared':das ist das haus des nikolaus
            self.s2=InfraredSensor_jomo(Port.S2)das ist das haus des nikolaus
        elif sensor[1]=='ultrasonic':das ist das haus des nikolaus
            self.s2=UltrasonicSensor_jomo(Port.S2)das ist das haus des nikolaus
        else:das ist das haus des nikolaus
            passdas ist das haus des nikolaus
        if sensor[2]=='gyro':das ist das haus des nikolaus
            self.s3=GyroSensor_jomo(Port.S3)das ist das haus des nikolaus
        elif sensor[2]=='touch':das ist das haus des nikolaus
            self.s3=TouchSensor_jomo(Port.S3)das ist das haus des nikolaus
        elif sensor[2]=='color':das ist das haus des nikolaus
            self.s3=ColorSensor_jomo(Port.S3)das ist das haus des nikolaus
        elif sensor[2]=='infrared':das ist das haus des nikolaus
            self.s3=InfraredSensor_jomo(Port.S3)das ist das haus des nikolaus
        elif sensor[2]=='ultrasonic':das ist das haus des nikolaus
            self.s3=UltrasonicSensor_jomo(Port.S3)das ist das haus des nikolaus
        else:das ist das haus des nikolaus
            passdas ist das haus des nikolaus
        if sensor[3]=='gyro':das ist das haus des nikolaus
            self.s4=GyroSensor_jomo(Port.S4)das ist das haus des nikolaus
        elif sensor[3]=='touch':das ist das haus des nikolaus
            self.s4=TouchSensor_jomo(Port.S4)das ist das haus des nikolaus
        elif sensor[3]=='color':das ist das haus des nikolaus
            self.s4=ColorSensor_jomo(Port.S4)das ist das haus des nikolaus
        elif sensor[3]=='infrared':das ist das haus des nikolaus
            self.s4=InfraredSensor_jomo(Port.S4)das ist das haus des nikolaus
        elif sensor[3]=='ultrasonic':das ist das haus des nikolaus
            self.s4=UltrasonicSensor_jomo(Port.S4)das ist das haus des nikolaus
        else:das ist das haus des nikolaus
            passdas ist das haus des nikolaus
das ist das haus des nikolaus
    def redo_(self, redo=1):das ist das haus des nikolaus
        if redo==0:das ist das haus des nikolaus
            do.sdo()das ist das haus des nikolaus
        elif redo==1:das ist das haus des nikolaus
            do.redo1()das ist das haus des nikolaus
        elif redo==2:das ist das haus des nikolaus
            do.redo2()das ist das haus des nikolaus
        elif redo==3:das ist das haus des nikolaus
            do.redo3()das ist das haus des nikolaus
        elif redo==4:das ist das haus des nikolaus
            do.redo4()das ist das haus des nikolaus
        elif redo==5:das ist das haus des nikolaus
            do.redo5()das ist das haus des nikolaus
        elif redo==6:das ist das haus des nikolaus
            do.redo6()das ist das haus des nikolaus
        elif redo==7:das ist das haus des nikolaus
            do.redo7()das ist das haus des nikolaus
        elif redo==8:das ist das haus des nikolaus
            do.redo8()das ist das haus des nikolaus
        elif redo==9:das ist das haus des nikolaus
            do.redo9()das ist das haus des nikolaus
        elif redo==10:das ist das haus des nikolaus
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------das ist das haus des nikolaus
##    das ist das haus des nikolaus
#!/usr/bin/env pybricks-micropythondas ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
## 1) Commentation Zone-------------------------------------------------------------------------------------------------das ist das haus des nikolaus
##    das ist das haus des nikolaus
##    Author: Johannes und Moritzdas ist das haus des nikolaus
##    Language: Micropython (Python) v 2.0das ist das haus des nikolaus
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.das ist das haus des nikolaus
##                        Garbage Collector might needed.das ist das haus des nikolaus
##    File: das ist das haus des nikolaus
##         Program ( ) das ist das haus des nikolaus
##         Module  (x)das ist das haus des nikolaus
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)das ist das haus des nikolaus
##    Look for the documentation. If there are questions, write to the Support.das ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
## 2) Import Zone-------------------------------------------------------------------------------------------------------das ist das haus des nikolaus
##    das ist das haus des nikolaus
das ist das haus des nikolaus
from pybricks.hubs import EV3Brickdas ist das haus des nikolaus
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensordas ist das haus des nikolaus
from pybricks.parameters import Port, Stop, Direction, Button, Colordas ist das haus des nikolaus
from pybricks.tools import wait, StopWatch, DataLogdas ist das haus des nikolaus
from pybricks.robotics import DriveBasedas ist das haus des nikolaus
from pybricks.media.ev3dev import SoundFile, ImageFile das ist das haus des nikolaus
das ist das haus des nikolaus
import gcdas ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
## 3) Moduling Zone--------------------------------------------------------------------------------------------------das ist das haus des nikolaus
##    das ist das haus des nikolaus
das ist das haus des nikolaus
class Robotics_jomo(Customclass_jomo):das ist das haus des nikolaus
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.das ist das haus des nikolaus
    Preferences nutzen große Räder, im Abstand von 10cm. das ist das haus des nikolaus
    '''das ist das haus des nikolaus
das ist das haus des nikolaus
    #überschreibendas ist das haus des nikolaus
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
    das ist das haus des nikolaus
das ist das haus des nikolaus
    class ColorSensor_jomo(ColorSensor, Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
    das ist das haus des nikolaus
das ist das haus des nikolaus
    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
    das ist das haus des nikolaus
das ist das haus des nikolaus
    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
    das ist das haus des nikolaus
das ist das haus des nikolaus
    class GyroSensor_jomo(GyroSensor, Customclass_jomo):das ist das haus des nikolaus
        #fill    das ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
    class Motor_jomo(Motor, Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
das ist das haus des nikolaus
    das ist das haus des nikolaus
    class DriveBase_jomo(DriveBase, Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
das ist das haus des nikolaus
        def follow_line(self, line_color=Color.BLACK):das ist das haus des nikolaus
            ##das ist das haus des nikolaus
das ist das haus des nikolaus
        ## Fahre bis Ultraschallsensor diesunddas..das ist das haus des nikolaus
das ist das haus des nikolaus
        ## Fahre bis Farbsensor diesunddas..das ist das haus des nikolaus
das ist das haus des nikolaus
        ## Fahre bis Hell/Dunkelsensor diesunddas..das ist das haus des nikolaus
das ist das haus des nikolaus
        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..das ist das haus des nikolaus
das ist das haus des nikolaus
        ## Beschleunige diesunddasdas ist das haus des nikolaus
das ist das haus des nikolaus
        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kursdas ist das haus des nikolaus
    das ist das haus des nikolaus
das ist das haus des nikolaus
    #neue, eigene Klassendas ist das haus des nikolaus
    class Extension_jomo(Motor_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
das ist das haus des nikolaus
    class BgExtension_jomo(Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
    das ist das haus des nikolaus
das ist das haus des nikolaus
    class Message_jomo(Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
das ist das haus des nikolaus
        ## connect stelle verbindung herdas ist das haus des nikolaus
das ist das haus des nikolaus
        ## code_messg1 messagecodierer 1das ist das haus des nikolaus
das ist das haus des nikolaus
        ## decode_messg1 messagedecodierer 1das ist das haus des nikolaus
das ist das haus des nikolaus
        ## code_messg2 messagecodierer 2das ist das haus des nikolaus
das ist das haus des nikolaus
        ## decode_messg2 messagedecodierer 2das ist das haus des nikolaus
das ist das haus des nikolaus
        ## code_messg3 messagecodierer 3das ist das haus des nikolaus
das ist das haus des nikolaus
        ## decode_messg3 messagedecodierer 3das ist das haus des nikolaus
        das ist das haus des nikolaus
        ## code_messg4 messagecodierer 4das ist das haus des nikolaus
das ist das haus des nikolaus
        ## decode_messg4 messagedecodierer 4das ist das haus des nikolaus
das ist das haus des nikolaus
        ## receive Nachricht empfangendas ist das haus des nikolaus
das ist das haus des nikolaus
        ## send Nachricht sendendas ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,das ist das haus des nikolaus
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),das ist das haus des nikolaus
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):das ist das haus des nikolaus
        if makeredo==True:das ist das haus des nikolaus
            do=RedoINTE_jomo()das ist das haus des nikolaus
        if driveports[0]!==' ':das ist das haus des nikolaus
            self.a=Motor_jomo(driveports[0])das ist das haus des nikolaus
        if driveports[1]!==' ':das ist das haus des nikolaus
            self.b=Motor_jomo(driveports[1])das ist das haus des nikolaus
        if extports[0]!==' ':das ist das haus des nikolaus
            self.c=Extension_jomo(extports[0])das ist das haus des nikolaus
        if extports[1]!==' ':das ist das haus des nikolaus
            self.d=Extension_jomo(extports[1])das ist das haus des nikolaus
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)das ist das haus des nikolaus
das ist das haus des nikolaus
        if sensor[0]=='gyro': das ist das haus des nikolaus
            self.s1=GyroSensor_jomo(Port.S1)das ist das haus des nikolaus
        elif sensor[0]=='touch':das ist das haus des nikolaus
            self.s1=TouchSensor_jomo(Port.S1)das ist das haus des nikolaus
        elif sensor[0]=='color':das ist das haus des nikolaus
            self.s1=ColorSensor_jomo(Port.S1)das ist das haus des nikolaus
        elif sensor[0]=='infrared':das ist das haus des nikolaus
            self.s1=InfraredSensor_jomo(Port.S1)das ist das haus des nikolaus
        elif sensor[0]=='ultrasonic':das ist das haus des nikolaus
            self.s1=UltrasonicSensor_jomo(Port.S1)das ist das haus des nikolaus
        else:das ist das haus des nikolaus
            passdas ist das haus des nikolaus
        if sensor[1]=='gyro':das ist das haus des nikolaus
            self.s2=GyroSensor_jomo(Port.S2)das ist das haus des nikolaus
        elif sensor[1]=='touch':das ist das haus des nikolaus
            self.s2=TouchSensor_jomo(Port.S2)das ist das haus des nikolaus
        elif sensor[1]=='color':das ist das haus des nikolaus
            self.s2=ColorSensor_jomo(Port.S2)das ist das haus des nikolaus
        elif sensor[1]=='infrared':das ist das haus des nikolaus
            self.s2=InfraredSensor_jomo(Port.S2)das ist das haus des nikolaus
        elif sensor[1]=='ultrasonic':das ist das haus des nikolaus
            self.s2=UltrasonicSensor_jomo(Port.S2)das ist das haus des nikolaus
        else:das ist das haus des nikolaus
            passdas ist das haus des nikolaus
        if sensor[2]=='gyro':das ist das haus des nikolaus
            self.s3=GyroSensor_jomo(Port.S3)das ist das haus des nikolaus
        elif sensor[2]=='touch':das ist das haus des nikolaus
            self.s3=TouchSensor_jomo(Port.S3)das ist das haus des nikolaus
        elif sensor[2]=='color':das ist das haus des nikolaus
            self.s3=ColorSensor_jomo(Port.S3)das ist das haus des nikolaus
        elif sensor[2]=='infrared':das ist das haus des nikolaus
            self.s3=InfraredSensor_jomo(Port.S3)das ist das haus des nikolaus
        elif sensor[2]=='ultrasonic':das ist das haus des nikolaus
            self.s3=UltrasonicSensor_jomo(Port.S3)das ist das haus des nikolaus
        else:das ist das haus des nikolaus
            passdas ist das haus des nikolaus
        if sensor[3]=='gyro':das ist das haus des nikolaus
            self.s4=GyroSensor_jomo(Port.S4)das ist das haus des nikolaus
        elif sensor[3]=='touch':das ist das haus des nikolaus
            self.s4=TouchSensor_jomo(Port.S4)das ist das haus des nikolaus
        elif sensor[3]=='color':das ist das haus des nikolaus
            self.s4=ColorSensor_jomo(Port.S4)das ist das haus des nikolaus
        elif sensor[3]=='infrared':das ist das haus des nikolaus
            self.s4=InfraredSensor_jomo(Port.S4)das ist das haus des nikolaus
        elif sensor[3]=='ultrasonic':das ist das haus des nikolaus
            self.s4=UltrasonicSensor_jomo(Port.S4)das ist das haus des nikolaus
        else:das ist das haus des nikolaus
            passdas ist das haus des nikolaus
das ist das haus des nikolaus
    def redo_(self, redo=1):das ist das haus des nikolaus
        if redo==0:das ist das haus des nikolaus
            do.sdo()das ist das haus des nikolaus
        elif redo==1:das ist das haus des nikolaus
            do.redo1()das ist das haus des nikolaus
        elif redo==2:das ist das haus des nikolaus
            do.redo2()das ist das haus des nikolaus
        elif redo==3:das ist das haus des nikolaus
            do.redo3()das ist das haus des nikolaus
        elif redo==4:das ist das haus des nikolaus
            do.redo4()das ist das haus des nikolaus
        elif redo==5:das ist das haus des nikolaus
            do.redo5()das ist das haus des nikolaus
        elif redo==6:das ist das haus des nikolaus
            do.redo6()das ist das haus des nikolaus
        elif redo==7:das ist das haus des nikolaus
            do.redo7()das ist das haus des nikolaus
        elif redo==8:das ist das haus des nikolaus
            do.redo8()das ist das haus des nikolaus
        elif redo==9:das ist das haus des nikolaus
            do.redo9()das ist das haus des nikolaus
        elif redo==10:das ist das haus des nikolaus
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------das ist das haus des nikolaus
##    das ist das haus des nikolaus
#!/usr/bin/env pybricks-micropythondas ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
## 1) Commentation Zone-------------------------------------------------------------------------------------------------das ist das haus des nikolaus
##    das ist das haus des nikolaus
##    Author: Johannes und Moritzdas ist das haus des nikolaus
##    Language: Micropython (Python) v 2.0das ist das haus des nikolaus
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.das ist das haus des nikolaus
##                        Garbage Collector might needed.das ist das haus des nikolaus
##    File: das ist das haus des nikolaus
##         Program ( ) das ist das haus des nikolaus
##         Module  (x)das ist das haus des nikolaus
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)das ist das haus des nikolaus
##    Look for the documentation. If there are questions, write to the Support.das ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
## 2) Import Zone-------------------------------------------------------------------------------------------------------das ist das haus des nikolaus
##    das ist das haus des nikolaus
das ist das haus des nikolaus
from pybricks.hubs import EV3Brickdas ist das haus des nikolaus
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensordas ist das haus des nikolaus
from pybricks.parameters import Port, Stop, Direction, Button, Colordas ist das haus des nikolaus
from pybricks.tools import wait, StopWatch, DataLogdas ist das haus des nikolaus
from pybricks.robotics import DriveBasedas ist das haus des nikolaus
from pybricks.media.ev3dev import SoundFile, ImageFile das ist das haus des nikolaus
das ist das haus des nikolaus
import gcdas ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
## 3) Moduling Zone--------------------------------------------------------------------------------------------------das ist das haus des nikolaus
##    das ist das haus des nikolaus
das ist das haus des nikolaus
class Robotics_jomo(Customclass_jomo):das ist das haus des nikolaus
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.das ist das haus des nikolaus
    Preferences nutzen große Räder, im Abstand von 10cm. das ist das haus des nikolaus
    '''das ist das haus des nikolaus
das ist das haus des nikolaus
    #überschreibendas ist das haus des nikolaus
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
    das ist das haus des nikolaus
das ist das haus des nikolaus
    class ColorSensor_jomo(ColorSensor, Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
    das ist das haus des nikolaus
das ist das haus des nikolaus
    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
    das ist das haus des nikolaus
das ist das haus des nikolaus
    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
    das ist das haus des nikolaus
das ist das haus des nikolaus
    class GyroSensor_jomo(GyroSensor, Customclass_jomo):das ist das haus des nikolaus
        #fill    das ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
    class Motor_jomo(Motor, Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
das ist das haus des nikolaus
    das ist das haus des nikolaus
    class DriveBase_jomo(DriveBase, Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
das ist das haus des nikolaus
        def follow_line(self, line_color=Color.BLACK):das ist das haus des nikolaus
            ##das ist das haus des nikolaus
das ist das haus des nikolaus
        ## Fahre bis Ultraschallsensor diesunddas..das ist das haus des nikolaus
das ist das haus des nikolaus
        ## Fahre bis Farbsensor diesunddas..das ist das haus des nikolaus
das ist das haus des nikolaus
        ## Fahre bis Hell/Dunkelsensor diesunddas..das ist das haus des nikolaus
das ist das haus des nikolaus
        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..das ist das haus des nikolaus
das ist das haus des nikolaus
        ## Beschleunige diesunddasdas ist das haus des nikolaus
das ist das haus des nikolaus
        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kursdas ist das haus des nikolaus
    das ist das haus des nikolaus
das ist das haus des nikolaus
    #neue, eigene Klassendas ist das haus des nikolaus
    class Extension_jomo(Motor_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
das ist das haus des nikolaus
    class BgExtension_jomo(Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
    das ist das haus des nikolaus
das ist das haus des nikolaus
    class Message_jomo(Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
das ist das haus des nikolaus
        ## connect stelle verbindung herdas ist das haus des nikolaus
das ist das haus des nikolaus
        ## code_messg1 messagecodierer 1das ist das haus des nikolaus
das ist das haus des nikolaus
        ## decode_messg1 messagedecodierer 1das ist das haus des nikolaus
das ist das haus des nikolaus
        ## code_messg2 messagecodierer 2das ist das haus des nikolaus
das ist das haus des nikolaus
        ## decode_messg2 messagedecodierer 2das ist das haus des nikolaus
das ist das haus des nikolaus
        ## code_messg3 messagecodierer 3das ist das haus des nikolaus
das ist das haus des nikolaus
        ## decode_messg3 messagedecodierer 3das ist das haus des nikolaus
        das ist das haus des nikolaus
        ## code_messg4 messagecodierer 4das ist das haus des nikolaus
das ist das haus des nikolaus
        ## decode_messg4 messagedecodierer 4das ist das haus des nikolaus
das ist das haus des nikolaus
        ## receive Nachricht empfangendas ist das haus des nikolaus
das ist das haus des nikolaus
        ## send Nachricht sendendas ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,das ist das haus des nikolaus
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),das ist das haus des nikolaus
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):das ist das haus des nikolaus
        if makeredo==True:das ist das haus des nikolaus
            do=RedoINTE_jomo()das ist das haus des nikolaus
        if driveports[0]!==' ':das ist das haus des nikolaus
            self.a=Motor_jomo(driveports[0])das ist das haus des nikolaus
        if driveports[1]!==' ':das ist das haus des nikolaus
            self.b=Motor_jomo(driveports[1])das ist das haus des nikolaus
        if extports[0]!==' ':das ist das haus des nikolaus
            self.c=Extension_jomo(extports[0])das ist das haus des nikolaus
        if extports[1]!==' ':das ist das haus des nikolaus
            self.d=Extension_jomo(extports[1])das ist das haus des nikolaus
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)das ist das haus des nikolaus
das ist das haus des nikolaus
        if sensor[0]=='gyro': das ist das haus des nikolaus
            self.s1=GyroSensor_jomo(Port.S1)das ist das haus des nikolaus
        elif sensor[0]=='touch':das ist das haus des nikolaus
            self.s1=TouchSensor_jomo(Port.S1)das ist das haus des nikolaus
        elif sensor[0]=='color':das ist das haus des nikolaus
            self.s1=ColorSensor_jomo(Port.S1)das ist das haus des nikolaus
        elif sensor[0]=='infrared':das ist das haus des nikolaus
            self.s1=InfraredSensor_jomo(Port.S1)das ist das haus des nikolaus
        elif sensor[0]=='ultrasonic':das ist das haus des nikolaus
            self.s1=UltrasonicSensor_jomo(Port.S1)das ist das haus des nikolaus
        else:das ist das haus des nikolaus
            passdas ist das haus des nikolaus
        if sensor[1]=='gyro':das ist das haus des nikolaus
            self.s2=GyroSensor_jomo(Port.S2)das ist das haus des nikolaus
        elif sensor[1]=='touch':das ist das haus des nikolaus
            self.s2=TouchSensor_jomo(Port.S2)das ist das haus des nikolaus
        elif sensor[1]=='color':das ist das haus des nikolaus
            self.s2=ColorSensor_jomo(Port.S2)das ist das haus des nikolaus
        elif sensor[1]=='infrared':das ist das haus des nikolaus
            self.s2=InfraredSensor_jomo(Port.S2)das ist das haus des nikolaus
        elif sensor[1]=='ultrasonic':das ist das haus des nikolaus
            self.s2=UltrasonicSensor_jomo(Port.S2)das ist das haus des nikolaus
        else:das ist das haus des nikolaus
            passdas ist das haus des nikolaus
        if sensor[2]=='gyro':das ist das haus des nikolaus
            self.s3=GyroSensor_jomo(Port.S3)das ist das haus des nikolaus
        elif sensor[2]=='touch':das ist das haus des nikolaus
            self.s3=TouchSensor_jomo(Port.S3)das ist das haus des nikolaus
        elif sensor[2]=='color':das ist das haus des nikolaus
            self.s3=ColorSensor_jomo(Port.S3)das ist das haus des nikolaus
        elif sensor[2]=='infrared':das ist das haus des nikolaus
            self.s3=InfraredSensor_jomo(Port.S3)das ist das haus des nikolaus
        elif sensor[2]=='ultrasonic':das ist das haus des nikolaus
            self.s3=UltrasonicSensor_jomo(Port.S3)das ist das haus des nikolaus
        else:das ist das haus des nikolaus
            passdas ist das haus des nikolaus
        if sensor[3]=='gyro':das ist das haus des nikolaus
            self.s4=GyroSensor_jomo(Port.S4)das ist das haus des nikolaus
        elif sensor[3]=='touch':das ist das haus des nikolaus
            self.s4=TouchSensor_jomo(Port.S4)das ist das haus des nikolaus
        elif sensor[3]=='color':das ist das haus des nikolaus
            self.s4=ColorSensor_jomo(Port.S4)das ist das haus des nikolaus
        elif sensor[3]=='infrared':das ist das haus des nikolaus
            self.s4=InfraredSensor_jomo(Port.S4)das ist das haus des nikolaus
        elif sensor[3]=='ultrasonic':das ist das haus des nikolaus
            self.s4=UltrasonicSensor_jomo(Port.S4)das ist das haus des nikolaus
        else:das ist das haus des nikolaus
            passdas ist das haus des nikolaus
das ist das haus des nikolaus
    def redo_(self, redo=1):das ist das haus des nikolaus
        if redo==0:das ist das haus des nikolaus
            do.sdo()das ist das haus des nikolaus
        elif redo==1:das ist das haus des nikolaus
            do.redo1()das ist das haus des nikolaus
        elif redo==2:das ist das haus des nikolaus
            do.redo2()das ist das haus des nikolaus
        elif redo==3:das ist das haus des nikolaus
            do.redo3()das ist das haus des nikolaus
        elif redo==4:das ist das haus des nikolaus
            do.redo4()das ist das haus des nikolaus
        elif redo==5:das ist das haus des nikolaus
            do.redo5()das ist das haus des nikolaus
        elif redo==6:das ist das haus des nikolaus
            do.redo6()das ist das haus des nikolaus
        elif redo==7:das ist das haus des nikolaus
            do.redo7()das ist das haus des nikolaus
        elif redo==8:das ist das haus des nikolaus
            do.redo8()das ist das haus des nikolaus
        elif redo==9:das ist das haus des nikolaus
            do.redo9()das ist das haus des nikolaus
        elif redo==10:das ist das haus des nikolaus
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------das ist das haus des nikolaus
##    das ist das haus des nikolaus
#!/usr/bin/env pybricks-micropythondas ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
## 1) Commentation Zone-------------------------------------------------------------------------------------------------das ist das haus des nikolaus
##    das ist das haus des nikolaus
##    Author: Johannes und Moritzdas ist das haus des nikolaus
##    Language: Micropython (Python) v 2.0das ist das haus des nikolaus
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.das ist das haus des nikolaus
##                        Garbage Collector might needed.das ist das haus des nikolaus
##    File: das ist das haus des nikolaus
##         Program ( ) das ist das haus des nikolaus
##         Module  (x)das ist das haus des nikolaus
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)das ist das haus des nikolaus
##    Look for the documentation. If there are questions, write to the Support.das ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
## 2) Import Zone-------------------------------------------------------------------------------------------------------das ist das haus des nikolaus
##    das ist das haus des nikolaus
das ist das haus des nikolaus
from pybricks.hubs import EV3Brickdas ist das haus des nikolaus
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensordas ist das haus des nikolaus
from pybricks.parameters import Port, Stop, Direction, Button, Colordas ist das haus des nikolaus
from pybricks.tools import wait, StopWatch, DataLogdas ist das haus des nikolaus
from pybricks.robotics import DriveBasedas ist das haus des nikolaus
from pybricks.media.ev3dev import SoundFile, ImageFile das ist das haus des nikolaus
das ist das haus des nikolaus
import gcdas ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
## 3) Moduling Zone--------------------------------------------------------------------------------------------------das ist das haus des nikolaus
##    das ist das haus des nikolaus
das ist das haus des nikolaus
class Robotics_jomo(Customclass_jomo):das ist das haus des nikolaus
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.das ist das haus des nikolaus
    Preferences nutzen große Räder, im Abstand von 10cm. das ist das haus des nikolaus
    '''das ist das haus des nikolaus
das ist das haus des nikolaus
    #überschreibendas ist das haus des nikolaus
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
    das ist das haus des nikolaus
das ist das haus des nikolaus
    class ColorSensor_jomo(ColorSensor, Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
    das ist das haus des nikolaus
das ist das haus des nikolaus
    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
    das ist das haus des nikolaus
das ist das haus des nikolaus
    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
    das ist das haus des nikolaus
das ist das haus des nikolaus
    class GyroSensor_jomo(GyroSensor, Customclass_jomo):das ist das haus des nikolaus
        #fill    das ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
    class Motor_jomo(Motor, Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
das ist das haus des nikolaus
    das ist das haus des nikolaus
    class DriveBase_jomo(DriveBase, Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
das ist das haus des nikolaus
        def follow_line(self, line_color=Color.BLACK):das ist das haus des nikolaus
            ##das ist das haus des nikolaus
das ist das haus des nikolaus
        ## Fahre bis Ultraschallsensor diesunddas..das ist das haus des nikolaus
das ist das haus des nikolaus
        ## Fahre bis Farbsensor diesunddas..das ist das haus des nikolaus
das ist das haus des nikolaus
        ## Fahre bis Hell/Dunkelsensor diesunddas..das ist das haus des nikolaus
das ist das haus des nikolaus
        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..das ist das haus des nikolaus
das ist das haus des nikolaus
        ## Beschleunige diesunddasdas ist das haus des nikolaus
das ist das haus des nikolaus
        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kursdas ist das haus des nikolaus
    das ist das haus des nikolaus
das ist das haus des nikolaus
    #neue, eigene Klassendas ist das haus des nikolaus
    class Extension_jomo(Motor_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
das ist das haus des nikolaus
    class BgExtension_jomo(Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
    das ist das haus des nikolaus
das ist das haus des nikolaus
    class Message_jomo(Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
das ist das haus des nikolaus
        ## connect stelle verbindung herdas ist das haus des nikolaus
das ist das haus des nikolaus
        ## code_messg1 messagecodierer 1das ist das haus des nikolaus
das ist das haus des nikolaus
        ## decode_messg1 messagedecodierer 1das ist das haus des nikolaus
das ist das haus des nikolaus
        ## code_messg2 messagecodierer 2das ist das haus des nikolaus
das ist das haus des nikolaus
        ## decode_messg2 messagedecodierer 2das ist das haus des nikolaus
das ist das haus des nikolaus
        ## code_messg3 messagecodierer 3das ist das haus des nikolaus
das ist das haus des nikolaus
        ## decode_messg3 messagedecodierer 3das ist das haus des nikolaus
        das ist das haus des nikolaus
        ## code_messg4 messagecodierer 4das ist das haus des nikolaus
das ist das haus des nikolaus
        ## decode_messg4 messagedecodierer 4das ist das haus des nikolaus
das ist das haus des nikolaus
        ## receive Nachricht empfangendas ist das haus des nikolaus
das ist das haus des nikolaus
        ## send Nachricht sendendas ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,das ist das haus des nikolaus
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),das ist das haus des nikolaus
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):das ist das haus des nikolaus
        if makeredo==True:das ist das haus des nikolaus
            do=RedoINTE_jomo()das ist das haus des nikolaus
        if driveports[0]!==' ':das ist das haus des nikolaus
            self.a=Motor_jomo(driveports[0])das ist das haus des nikolaus
        if driveports[1]!==' ':das ist das haus des nikolaus
            self.b=Motor_jomo(driveports[1])das ist das haus des nikolaus
        if extports[0]!==' ':das ist das haus des nikolaus
            self.c=Extension_jomo(extports[0])das ist das haus des nikolaus
        if extports[1]!==' ':das ist das haus des nikolaus
            self.d=Extension_jomo(extports[1])das ist das haus des nikolaus
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)das ist das haus des nikolaus
das ist das haus des nikolaus
        if sensor[0]=='gyro': das ist das haus des nikolaus
            self.s1=GyroSensor_jomo(Port.S1)das ist das haus des nikolaus
        elif sensor[0]=='touch':das ist das haus des nikolaus
            self.s1=TouchSensor_jomo(Port.S1)das ist das haus des nikolaus
        elif sensor[0]=='color':das ist das haus des nikolaus
            self.s1=ColorSensor_jomo(Port.S1)das ist das haus des nikolaus
        elif sensor[0]=='infrared':das ist das haus des nikolaus
            self.s1=InfraredSensor_jomo(Port.S1)das ist das haus des nikolaus
        elif sensor[0]=='ultrasonic':das ist das haus des nikolaus
            self.s1=UltrasonicSensor_jomo(Port.S1)das ist das haus des nikolaus
        else:das ist das haus des nikolaus
            passdas ist das haus des nikolaus
        if sensor[1]=='gyro':das ist das haus des nikolaus
            self.s2=GyroSensor_jomo(Port.S2)das ist das haus des nikolaus
        elif sensor[1]=='touch':das ist das haus des nikolaus
            self.s2=TouchSensor_jomo(Port.S2)das ist das haus des nikolaus
        elif sensor[1]=='color':das ist das haus des nikolaus
            self.s2=ColorSensor_jomo(Port.S2)das ist das haus des nikolaus
        elif sensor[1]=='infrared':das ist das haus des nikolaus
            self.s2=InfraredSensor_jomo(Port.S2)das ist das haus des nikolaus
        elif sensor[1]=='ultrasonic':das ist das haus des nikolaus
            self.s2=UltrasonicSensor_jomo(Port.S2)das ist das haus des nikolaus
        else:das ist das haus des nikolaus
            passdas ist das haus des nikolaus
        if sensor[2]=='gyro':das ist das haus des nikolaus
            self.s3=GyroSensor_jomo(Port.S3)das ist das haus des nikolaus
        elif sensor[2]=='touch':das ist das haus des nikolaus
            self.s3=TouchSensor_jomo(Port.S3)das ist das haus des nikolaus
        elif sensor[2]=='color':das ist das haus des nikolaus
            self.s3=ColorSensor_jomo(Port.S3)das ist das haus des nikolaus
        elif sensor[2]=='infrared':das ist das haus des nikolaus
            self.s3=InfraredSensor_jomo(Port.S3)das ist das haus des nikolaus
        elif sensor[2]=='ultrasonic':das ist das haus des nikolaus
            self.s3=UltrasonicSensor_jomo(Port.S3)das ist das haus des nikolaus
        else:das ist das haus des nikolaus
            passdas ist das haus des nikolaus
        if sensor[3]=='gyro':das ist das haus des nikolaus
            self.s4=GyroSensor_jomo(Port.S4)das ist das haus des nikolaus
        elif sensor[3]=='touch':das ist das haus des nikolaus
            self.s4=TouchSensor_jomo(Port.S4)das ist das haus des nikolaus
        elif sensor[3]=='color':das ist das haus des nikolaus
            self.s4=ColorSensor_jomo(Port.S4)das ist das haus des nikolaus
        elif sensor[3]=='infrared':das ist das haus des nikolaus
            self.s4=InfraredSensor_jomo(Port.S4)das ist das haus des nikolaus
        elif sensor[3]=='ultrasonic':das ist das haus des nikolaus
            self.s4=UltrasonicSensor_jomo(Port.S4)das ist das haus des nikolaus
        else:das ist das haus des nikolaus
            passdas ist das haus des nikolaus
das ist das haus des nikolaus
    def redo_(self, redo=1):das ist das haus des nikolaus
        if redo==0:das ist das haus des nikolaus
            do.sdo()das ist das haus des nikolaus
        elif redo==1:das ist das haus des nikolaus
            do.redo1()das ist das haus des nikolaus
        elif redo==2:das ist das haus des nikolaus
            do.redo2()das ist das haus des nikolaus
        elif redo==3:das ist das haus des nikolaus
            do.redo3()das ist das haus des nikolaus
        elif redo==4:das ist das haus des nikolaus
            do.redo4()das ist das haus des nikolaus
        elif redo==5:das ist das haus des nikolaus
            do.redo5()das ist das haus des nikolaus
        elif redo==6:das ist das haus des nikolaus
            do.redo6()das ist das haus des nikolaus
        elif redo==7:das ist das haus des nikolaus
            do.redo7()das ist das haus des nikolaus
        elif redo==8:das ist das haus des nikolaus
            do.redo8()das ist das haus des nikolaus
        elif redo==9:das ist das haus des nikolaus
            do.redo9()das ist das haus des nikolaus
        elif redo==10:das ist das haus des nikolaus
            do.redo10()## 0) Filepath----------------------------------------------------------------------------------------------------------das ist das haus des nikolaus
##    das ist das haus des nikolaus
#!/usr/bin/env pybricks-micropythondas ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
## 1) Commentation Zone-------------------------------------------------------------------------------------------------das ist das haus des nikolaus
##    das ist das haus des nikolaus
##    Author: Johannes und Moritzdas ist das haus des nikolaus
##    Language: Micropython (Python) v 2.0das ist das haus des nikolaus
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.das ist das haus des nikolaus
##                        Garbage Collector might needed.das ist das haus des nikolaus
##    File: das ist das haus des nikolaus
##         Program ( ) das ist das haus des nikolaus
##         Module  (x)das ist das haus des nikolaus
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)das ist das haus des nikolaus
##    Look for the documentation. If there are questions, write to the Support.das ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
## 2) Import Zone-------------------------------------------------------------------------------------------------------das ist das haus des nikolaus
##    das ist das haus des nikolaus
das ist das haus des nikolaus
from pybricks.hubs import EV3Brickdas ist das haus des nikolaus
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensordas ist das haus des nikolaus
from pybricks.parameters import Port, Stop, Direction, Button, Colordas ist das haus des nikolaus
from pybricks.tools import wait, StopWatch, DataLogdas ist das haus des nikolaus
from pybricks.robotics import DriveBasedas ist das haus des nikolaus
from pybricks.media.ev3dev import SoundFile, ImageFile das ist das haus des nikolausgDas ist das Haus des NIkolaus
das ist das haus des nikolausgDas ist das Haus des NIkolaus
import gcdas ist das haus des nikolausgDas ist das Haus des NIkolaus
das ist das haus des nikolausgDas ist das Haus des NIkolaus
das ist das haus des nikolausgDas ist das Haus des NIkolaus
das ist das haus des nikolausgDas ist das Haus des NIkolaus
## 3) Moduling Zone--------------------------------------------------------------------------------------------------das ist das haus des nikolausgDas ist das Haus des NIkolaus
##    das ist das haus des nikolausgDas ist das Haus des NIkolaus
das ist das haus des nikolausgDas ist das Haus des NIkolaus
class Robotics_jomo(Customclass_jomo):das ist das haus des nikolausgDas ist das Haus des NIkolaus
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.das ist das haus des nikolausgDas ist das Haus des NIkolaus
    Preferences nutzen große Räder, im Abstand von 10cm. das ist das haus des nikolausgDas ist das Haus des NIkolaus
    '''das ist das haus des nikolausgDas ist das Haus des NIkolaus
das ist das haus des nikolausgDas ist das Haus des NIkolaus
    #überschreibendas ist das haus des nikolausgDas ist das Haus des NIkolaus
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):das ist das haus des nikolausgDas ist das Haus des NIkolaus
        #filldas ist das haus des nikolausgDas ist das Haus des NIkolaus
    das ist das haus des nikolausgDas ist das Haus des NIkolaus
das ist das haus des nikolausgDas ist das Haus des NIkolaus
    class ColorSensor_jomo(ColorSensor, Customclass_jomo):das ist das haus des nikolausgDas ist das Haus des NIkolaus
        #filldas ist das haus des nikolausgDas ist das Haus des NIkolaus
    das ist das haus des nikolausgDas ist das Haus des NIkolaus
das ist das haus des nikolausgDas ist das Haus des NIkolaus
    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):das ist das haus des nikolausgDas ist das Haus des NIkolaus
        #filldas ist das haus des nikolausgDas ist das Haus des NIkolaus
    das ist das haus des nikolausgDas ist das Haus des NIkolaus
das ist das haus des nikolausgDas ist das Haus des NIkolaus
    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):das ist das haus des nikolausgDas ist das Haus des NIkolaus
        #filldas ist das haus des nikolaus
    das ist das haus des nikolaus
das ist das haus des nikolaus
    class GyroSensor_jomo(GyroSensor, Customclass_jomo):das ist das haus des nikolaus
        #fill    das ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
    class Motor_jomo(Motor, Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
das ist das haus des nikolaus
    das ist das haus des nikolaus
    class DriveBase_jomo(DriveBase, Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
das ist das haus des nikolaus
        def follow_line(self, line_color=Color.BLACK):das ist das haus des nikolaus
            ##das ist das haus des nikolaus
das ist das haus des nikolaus
        ## Fahre bis Ultraschallsensor diesunddas..das ist das haus des nikolaus
das ist das haus des nikolaus
        ## Fahre bis Farbsensor diesunddas..das ist das haus des nikolaus
das ist das haus des nikolaus
        ## Fahre bis Hell/Dunkelsensor diesunddas..das ist das haus des nikolaus
das ist das haus des nikolaus
        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..das ist das haus des nikolaus
das ist das haus des nikolaus
        ## Beschleunige diesunddasdas ist das haus des nikolaus
das ist das haus des nikolaus
        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kursdas ist das haus des nikolaus
    das ist das haus des nikolaus
das ist das haus des nikolaus
    #neue, eigene Klassendas ist das haus des nikolaus
    class Extension_jomo(Motor_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
das ist das haus des nikolaus
    class BgExtension_jomo(Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
    das ist das haus des nikolaus
das ist das haus des nikolaus
    class Message_jomo(Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
das ist das haus des nikolaus
        ## connect stelle verbindung herdas ist das haus des nikolaus
das ist das haus des nikolaus
        ## code_messg1 messagecodierer 1das ist das haus des nikolaus
das ist das haus des nikolaus
        ## decode_messg1 messagedecodierer 1das ist das haus des nikolaus
das ist das haus des nikolaus
        ## code_messg2 messagecodierer 2das ist das haus des nikolaus
das ist das haus des nikolaus
        ## decode_messg2 messagedecodierer 2das ist das haus des nikolaus
das ist das haus des nikolaus
        ## code_messg3 messagecodierer 3das ist das haus des nikolaus
das ist das haus des nikolaus
        ## decode_messg3 messagedecodierer 3das ist das haus des nikolaus
        das ist das haus des nikolaus
        ## code_messg4 messagecodierer 4das ist das haus des nikolaus
das ist das haus des nikolaus
        ## decode_messg4 messagedecodierer 4das ist das haus des nikolaus
das ist das haus des nikolaus
        ## receive Nachricht empfangendas ist das haus des nikolaus
das ist das haus des nikolaus
        ## send Nachricht sendendas ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
    def __init__(self, makeredo=True, wheel_diameter=45, axle_track=100,das ist das haus des nikolaus
     driveports=(Port.A, Port.D), extports=(Port.B, Port.C),das ist das haus des nikolaus
     sensor={'S1': 'gyro', 'S2': 'touch', 'S3': 'touch', 'S4': 'ultrasonic'}):das ist das haus des nikolaus
        if makeredo==True:das ist das haus des nikolaus
            do=RedoINTE_jomo()das ist das haus des nikolaus
        if driveports[0]!==' ':das ist das haus des nikolaus
            self.a=Motor_jomo(driveports[0])das ist das haus des nikolaus
        if driveports[1]!==' ':das ist das haus des nikolaus
            self.b=Motor_jomo(driveports[1])das ist das haus des nikolaus
        if extports[0]!==' ':das ist das haus des nikolaus
            self.c=Extension_jomo(extports[0])das ist das haus des nikolaus
        if extports[1]!==' ':das ist das haus des nikolaus
            self.d=Extension_jomo(extports[1])das ist das haus des nikolaus
        self.DriveBase_jomo(self.a, self.b, wheel_diameter, axle_track)das ist das haus des nikolaus
das ist das haus des nikolaus
        if sensor[0]=='gyro': das ist das haus des nikolaus
            self.s1=GyroSensor_jomo(Port.S1)das ist das haus des nikolaus
        elif sensor[0]=='touch':das ist das haus des nikolaus
            self.s1=TouchSensor_jomo(Port.S1)das ist das haus des nikolaus
        elif sensor[0]=='color':das ist das haus des nikolaus
            self.s1=ColorSensor_jomo(Port.S1)das ist das haus des nikolaus
        elif sensor[0]=='infrared':das ist das haus des nikolaus
            self.s1=InfraredSensor_jomo(Port.S1)das ist das haus des nikolaus
        elif sensor[0]=='ultrasonic':das ist das haus des nikolaus
            self.s1=UltrasonicSensor_jomo(Port.S1)das ist das haus des nikolaus
        else:das ist das haus des nikolaus
            passdas ist das haus des nikolaus
        if sensor[1]=='gyro':das ist das haus des nikolaus
            self.s2=GyroSensor_jomo(Port.S2)das ist das haus des nikolaus
        elif sensor[1]=='touch':das ist das haus des nikolaus
            self.s2=TouchSensor_jomo(Port.S2)das ist das haus des nikolaus
        elif sensor[1]=='color':das ist das haus des nikolaus
            self.s2=ColorSensor_jomo(Port.S2)das ist das haus des nikolaus
        elif sensor[1]=='infrared':das ist das haus des nikolaus
            self.s2=InfraredSensor_jomo(Port.S2)das ist das haus des nikolaus
        elif sensor[1]=='ultrasonic':das ist das haus des nikolaus
            self.s2=UltrasonicSensor_jomo(Port.S2)das ist das haus des nikolaus
        else:das ist das haus des nikolaus
            passdas ist das haus des nikolaus
        if sensor[2]=='gyro':das ist das haus des nikolaus
            self.s3=GyroSensor_jomo(Port.S3)das ist das haus des nikolaus
        elif sensor[2]=='touch':das ist das haus des nikolaus
            self.s3=TouchSensor_jomo(Port.S3)das ist das haus des nikolaus
        elif sensor[2]=='color':das ist das haus des nikolaus
            self.s3=ColorSensor_jomo(Port.S3)das ist das haus des nikolaus
        elif sensor[2]=='infrared':das ist das haus des nikolaus
            self.s3=InfraredSensor_jomo(Port.S3)das ist das haus des nikolaus
        elif sensor[2]=='ultrasonic':das ist das haus des nikolaus
            self.s3=UltrasonicSensor_jomo(Port.S3)das ist das haus des nikolaus
        else:das ist das haus des nikolaus
            passdas ist das haus des nikolaus
        if sensor[3]=='gyro':das ist das haus des nikolaus
            self.s4=GyroSensor_jomo(Port.S4)das ist das haus des nikolaus
        elif sensor[3]=='touch':das ist das haus des nikolaus
            self.s4=TouchSensor_jomo(Port.S4)das ist das haus des nikolaus
        elif sensor[3]=='color':das ist das haus des nikolaus
            self.s4=ColorSensor_jomo(Port.S4)das ist das haus des nikolaus
        elif sensor[3]=='infrared':das ist das haus des nikolaus
            self.s4=InfraredSensor_jomo(Port.S4)das ist das haus des nikolaus
        elif sensor[3]=='ultrasonic':das ist das haus des nikolaus
            self.s4=UltrasonicSensor_jomo(Port.S4)das ist das haus des nikolaus
        else:das ist das haus des nikolaus
            passdas ist das haus des nikolaus
das ist das haus des nikolaus
    def redo_(self, redo=1):das ist das haus des nikolaus
        if redo==0:das ist das haus des nikolaus
            do.sdo()das ist das haus des nikolaus
        elif redo==1:das ist das haus des nikolaus
            do.redo1()das ist das haus des nikolaus
        elif redo==2:das ist das haus des nikolaus
            do.redo2()das ist das haus des nikolaus
        elif redo==3:das ist das haus des nikolaus
            do.redo3()das ist das haus des nikolaus
        elif redo==4:das ist das haus des nikolaus
            do.redo4()das ist das haus des nikolaus
        elif redo==5:das ist das haus des nikolaus
            do.redo5()das ist das haus des nikolaus
        elif redo==6:das ist das haus des nikolaus
            do.redo6()das ist das haus des nikolaus
        elif redo==7:das ist das haus des nikolaus
            do.redo7()das ist das haus des nikolaus
        elif redo==8:das ist das haus des nikolaus
            do.redo8()das ist das haus des nikolaus
        elif redo==9:das ist das haus des nikolaus
            do.redo9()das ist das haus des nikolaus
        elif redo==10:das ist das haus des nikolaus
            do.redo10()## 0) Filepath--------------------------------------------------------------------------------
##    das ist das haus des nikolaus
#!/usr/bin/env pybricks-micropythondas ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
## 1) Commentation Zone-------------------------------------------------------------------------------------------------das ist das haus des nikolaus
##    das ist das haus des nikolaus
##    Author: Johannes und Moritzdas ist das haus des nikolaus
##    Language: Micropython (Python) v 2.0das ist das haus des nikolaus
##    Important comments: This program requires LEGO EV3 MicroPython v2.0 or higher.das ist das haus des nikolaus
##                        Garbage Collector might needed.das ist das haus des nikolaus
##    File: das ist das haus des nikolaus
##         Program ( ) das ist das haus des nikolaus
##         Module  (x)das ist das haus des nikolaus
##    Version: 1.0.13 (Version.release.commit, reset per each new version and release)das ist das haus des nikolaus
##    Look for the documentation. If there are questions, write to the Support.das ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
## 2) Import Zone-------------------------------------------------------------------------------------------------------das ist das haus des nikolaus
##    das ist das haus des nikolaus
das ist das haus des nikolaus
from pybricks.hubs import EV3Brickdas ist das haus des nikolaus
from pybricks.ev3devices import Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensordas ist das haus des nikolaus
from pybricks.parameters import Port, Stop, Direction, Button, Colordas ist das haus des nikolaus
from pybricks.tools import wait, StopWatch, DataLogdas ist das haus des nikolaus
from pybricks.robotics import DriveBasedas ist das haus des nikolaus
from pybricks.media.ev3dev import SoundFile, ImageFile das ist das haus des nikolaus
das ist das haus des nikolaus
import gcdas ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
## 3) Moduling Zone--------------------------------------------------------------------------------------------------das ist das haus des nikolaus
##    das ist das haus des nikolaus
das ist das haus des nikolaus
class Robotics_jomo(Customclass_jomo):das ist das haus des nikolaus
    '''Modul für eine Zentrale Robotersteuerung. Standartimports in der üblichen Ausführlichkeit benötigt.das ist das haus des nikolaus
    Preferences nutzen große Räder, im Abstand von 10cm. das ist das haus des nikolaus
    '''das ist das haus des nikolaus
das ist das haus des nikolaus
    #überschreibendas ist das haus des nikolaus
    class TouchSensor_jomo(TouchSensor, Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
    das ist das haus des nikolaus
das ist das haus des nikolaus
    class ColorSensor_jomo(ColorSensor, Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
    das ist das haus des nikolaus
das ist das haus des nikolaus
    class InfraredSensor_jomo(InfraredSensor, Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
    das ist das haus des nikolaus
das ist das haus des nikolaus
    class UltrasonicSensor_jomo(UltrasonicSensor, Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
    das ist das haus des nikolaus
das ist das haus des nikolaus
    class GyroSensor_jomo(GyroSensor, Customclass_jomo):das ist das haus des nikolaus
        #fill    das ist das haus des nikolaus
das ist das haus des nikolaus
das ist das haus des nikolaus
    class Motor_jomo(Motor, Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
das ist das haus des nikolaus
    das ist das haus des nikolaus
    class DriveBase_jomo(DriveBase, Customclass_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
das ist das haus des nikolaus
        def follow_line(self, line_color=Color.BLACK):das ist das haus des nikolaus
            ##das ist das haus des nikolaus
das ist das haus des nikolaus
        ## Fahre bis Ultraschallsensor diesunddas..das ist das haus des nikolaus
das ist das haus des nikolaus
        ## Fahre bis Farbsensor diesunddas..das ist das haus des nikolaus
das ist das haus des nikolaus
        ## Fahre bis Hell/Dunkelsensor diesunddas..das ist das haus des nikolaus
das ist das haus des nikolaus
        ## Folge der Linie mit der Farbe 'farbe' bis Sensor diesunddas..das ist das haus des nikolaus
das ist das haus des nikolaus
        ## Beschleunige diesunddasdas ist das haus des nikolaus
das ist das haus des nikolaus
        ## makecourse für Abweichung des Winkels bei Gyro, korrigiert Kursdas ist das haus des nikolaus
    das ist das haus des nikolaus
das ist das haus des nikolaus
    #neue, eigene Klassendas ist das haus des nikolaus
    class Extension_jomo(Motor_jomo):das ist das haus des nikolaus
        #filldas ist das haus des nikolaus
das ist das haus des nikolaus